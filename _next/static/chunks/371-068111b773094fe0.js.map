{"version":3,"file":"static/chunks/371-068111b773094fe0.js","mappings":"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","sources":["webpack://_N_E/./node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/utils/use-force-update.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/utils/use-motion-value-event.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/resize/handle-element.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/utils/resolve-element.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/resize/handle-window.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/scroll/info.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/scroll/track.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/render/dom/resize/index.mjs","webpack://_N_E/./node_modules/framer-motion/dist/es/value/use-scroll.mjs"],"sourcesContent":["import { useRef } from 'react';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-effect.mjs';\n\nfunction useIsMounted() {\n    const isMounted = useRef(false);\n    useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\n\nexport { useIsMounted };\n","import * as React from 'react';\nimport { useId, useRef, useInsertionEffect } from 'react';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n    getSnapshotBeforeUpdate(prevProps) {\n        const element = this.props.childRef.current;\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const size = this.props.sizeRef.current;\n            size.height = element.offsetHeight || 0;\n            size.width = element.offsetWidth || 0;\n            size.top = element.offsetTop;\n            size.left = element.offsetLeft;\n        }\n        return null;\n    }\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() { }\n    render() {\n        return this.props.children;\n    }\n}\nfunction PopChild({ children, isPresent }) {\n    const id = useId();\n    const ref = useRef(null);\n    const size = useRef({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n    });\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left } = size.current;\n        if (isPresent || !ref.current || !width || !height)\n            return;\n        ref.current.dataset.motionPopId = id;\n        const style = document.createElement(\"style\");\n        document.head.appendChild(style);\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            top: ${top}px !important;\n            left: ${left}px !important;\n          }\n        `);\n        }\n        return () => {\n            document.head.removeChild(style);\n        };\n    }, [isPresent]);\n    return (React.createElement(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size }, React.cloneElement(children, { ref })));\n}\n\nexport { PopChild };\n","import * as React from 'react';\nimport { useId, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = useId();\n    const context = useMemo(() => ({\n        id,\n        initial,\n        isPresent,\n        custom,\n        onExitComplete: (childId) => {\n            presenceChildren.set(childId, true);\n            for (const isComplete of presenceChildren.values()) {\n                if (!isComplete)\n                    return; // can stop searching when any is incomplete\n            }\n            onExitComplete && onExitComplete();\n        },\n        register: (childId) => {\n            presenceChildren.set(childId, false);\n            return () => presenceChildren.delete(childId);\n        },\n    }), \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === \"popLayout\") {\n        children = React.createElement(PopChild, { isPresent: isPresent }, children);\n    }\n    return (React.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","import * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { invariant } from '../../utils/errors.mjs';\n\nconst getChildKey = (child) => child.key || \"\";\nfunction updateChildLookup(children, allChildren) {\n    children.forEach((child) => {\n        const key = getChildKey(child);\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = \"sync\", }) => {\n    invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\");\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    const forceRender = useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];\n    const isMounted = useIsMounted();\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    const filteredChildren = onlyElements(children);\n    let childrenToRender = filteredChildren;\n    const exitingChildren = useRef(new Map()).current;\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    const presentChildren = useRef(childrenToRender);\n    // A lookup table to quickly reference components by key\n    const allChildren = useRef(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    const isInitialRender = useRef(true);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(() => {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exitingChildren.clear();\n    });\n    if (isInitialRender.current) {\n        return (React.createElement(React.Fragment, null, childrenToRender.map((child) => (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child)))));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = [...childrenToRender];\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    const presentKeys = presentChildren.current.map(getChildKey);\n    const targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    const numPresent = presentKeys.length;\n    for (let i = 0; i < numPresent; i++) {\n        const key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {\n            exitingChildren.set(key, undefined);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (mode === \"wait\" && exitingChildren.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exitingChildren.forEach((component, key) => {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        const child = allChildren.get(key);\n        if (!child)\n            return;\n        const insertionIndex = presentKeys.indexOf(key);\n        let exitingComponent = component;\n        if (!exitingComponent) {\n            const onExit = () => {\n                // clean up the exiting children map\n                exitingChildren.delete(key);\n                // compute the keys of children that were rendered once but are no longer present\n                // this could happen in case of too many fast consequent renderings\n                // @link https://github.com/framer/motion/issues/2023\n                const leftOverKeys = Array.from(allChildren.keys()).filter((childKey) => !targetKeys.includes(childKey));\n                // clean up the all children map\n                leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey));\n                // make sure to render only the children that are actually visible\n                presentChildren.current = filteredChildren.filter((presentChild) => {\n                    const presentChildKey = getChildKey(presentChild);\n                    return (\n                    // filter out the node exiting\n                    presentChildKey === key ||\n                        // filter out the leftover children\n                        leftOverKeys.includes(presentChildKey));\n                });\n                // Defer re-rendering until all exiting children have indeed left\n                if (!exitingChildren.size) {\n                    if (isMounted.current === false)\n                        return;\n                    forceRender();\n                    onExitComplete && onExitComplete();\n                }\n            };\n            exitingComponent = (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child));\n            exitingChildren.set(key, exitingComponent);\n        }\n        childrenToRender.splice(insertionIndex, 0, exitingComponent);\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map((child) => {\n        const key = child.key;\n        return exitingChildren.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child));\n    });\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        childrenToRender.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    return (React.createElement(React.Fragment, null, exitingChildren.size\n        ? childrenToRender\n        : childrenToRender.map((child) => cloneElement(child))));\n};\n\nexport { AnimatePresence };\n","import { useState, useCallback } from 'react';\nimport { useIsMounted } from './use-is-mounted.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\nfunction useForceUpdate() {\n    const isMounted = useIsMounted();\n    const [forcedRenderCount, setForcedRenderCount] = useState(0);\n    const forceRender = useCallback(() => {\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */\n    const deferredForceRender = useCallback(() => frame.postRender(forceRender), [forceRender]);\n    return [deferredForceRender, forcedRenderCount];\n}\n\nexport { useForceUpdate };\n","import { useEffect } from 'react';\n\nfunction useUnmountEffect(callback) {\n    return useEffect(() => () => callback(), []);\n}\n\nexport { useUnmountEffect };\n","import { useInsertionEffect } from 'react';\n\nfunction useMotionValueEvent(value, event, callback) {\n    /**\n     * useInsertionEffect will create subscriptions before any other\n     * effects will run. Effects run upwards through the tree so it\n     * can be that binding a useLayoutEffect higher up the tree can\n     * miss changes from lower down the tree.\n     */\n    useInsertionEffect(() => value.on(event, callback), [value, event, callback]);\n}\n\nexport { useMotionValueEvent };\n","import { resolveElements } from '../utils/resolve-element.mjs';\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nfunction getElementSize(target, borderBoxSize) {\n    if (borderBoxSize) {\n        const { inlineSize, blockSize } = borderBoxSize[0];\n        return { width: inlineSize, height: blockSize };\n    }\n    else if (target instanceof SVGElement && \"getBBox\" in target) {\n        return target.getBBox();\n    }\n    else {\n        return {\n            width: target.offsetWidth,\n            height: target.offsetHeight,\n        };\n    }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize, }) {\n    var _a;\n    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n        handler({\n            target,\n            contentSize: contentRect,\n            get size() {\n                return getElementSize(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer === null || observer === void 0 ? void 0 : observer.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n            }\n        });\n    };\n}\n\nexport { resizeElement };\n","import { invariant } from '../../../utils/errors.mjs';\n\nfunction resolveElements(elements, scope, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        let root = document;\n        if (scope) {\n            invariant(Boolean(scope.current), \"Scope provided, but no element detected.\");\n            root = scope.current;\n        }\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = root.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\nexport { resolveElements };\n","const windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const size = {\n            width: window.innerWidth,\n            height: window.innerHeight,\n        };\n        const info = {\n            target: window,\n            size,\n            contentSize: size,\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size && windowResizeHandler) {\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nexport { resizeWindow };\n","import { progress } from '../../../utils/progress.mjs';\nimport { velocityPerSecond } from '../../../utils/velocity-per-second.mjs';\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[\"scroll\" + position];\n    axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nexport { createScrollInfo, updateScrollInfo };\n","const ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nexport { ScrollOffset };\n","const namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (namedEdges[edge] !== undefined) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nexport { namedEdges, resolveEdge };\n","import { namedEdges, resolveEdge } from './edge.mjs';\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };\n","import { calcInset } from './inset.mjs';\nimport { ScrollOffset } from './presets.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { interpolate } from '../../../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../../../utils/offsets/default.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition));\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexport { resolveOffsets };\n","function calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n","import { warnOnce } from '../../../utils/warn-once.mjs';\nimport { updateScrollInfo } from './info.mjs';\nimport { resolveOffsets } from './offsets/index.mjs';\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: () => measure(element, options.target, info),\n        update: (time) => {\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n\nexport { createOnScrollHandler };\n","import { resize } from '../resize/index.mjs';\nimport { createScrollInfo } from './info.mjs';\nimport { createOnScrollHandler } from './on-scroll-handler.mjs';\nimport { frame, cancelFrame, frameData } from '../../../frameloop/frame.mjs';\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scrollInfo(onScroll, { container = document.documentElement, ...options } = {}) {\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers)\n                handler.measure();\n        };\n        const updateAll = () => {\n            for (const handler of containerHandlers) {\n                handler.update(frameData.timestamp);\n            }\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers)\n                handler.notify();\n        };\n        const listener = () => {\n            frame.read(measureAll, false, true);\n            frame.read(updateAll, false, true);\n            frame.update(notifyAll, false, true);\n        };\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        var _a;\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n    };\n}\n\nexport { scrollInfo };\n","import { resizeElement } from './handle-element.mjs';\nimport { resizeWindow } from './handle-window.mjs';\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\nexport { resize };\n","import { motionValue } from './index.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useEffect } from 'react';\nimport { warning } from '../utils/errors.mjs';\nimport { scrollInfo } from '../render/dom/scroll/track.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\n\nfunction refWarning(name, ref) {\n    warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \\`layoutEffect: false\\` option.`);\n}\nconst createScrollMotionValues = () => ({\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0),\n});\nfunction useScroll({ container, target, layoutEffect = true, ...options } = {}) {\n    const values = useConstant(createScrollMotionValues);\n    const useLifecycleEffect = layoutEffect\n        ? useIsomorphicLayoutEffect\n        : useEffect;\n    useLifecycleEffect(() => {\n        refWarning(\"target\", target);\n        refWarning(\"container\", container);\n        return scrollInfo(({ x, y }) => {\n            values.scrollX.set(x.current);\n            values.scrollXProgress.set(x.progress);\n            values.scrollY.set(y.current);\n            values.scrollYProgress.set(y.progress);\n        }, {\n            ...options,\n            container: (container === null || container === void 0 ? void 0 : container.current) || undefined,\n            target: (target === null || target === void 0 ? void 0 : target.current) || undefined,\n        });\n    }, [container, target, JSON.stringify(options.offset)]);\n    return values;\n}\n\nexport { useScroll };\n"],"names":["useIsMounted","isMounted","useRef","current","PopChildMeasure","getSnapshotBeforeUpdate","prevProps","element","this","props","childRef","isPresent","size","sizeRef","height","offsetHeight","width","offsetWidth","top","offsetTop","left","offsetLeft","componentDidUpdate","render","children","PopChild","id","useId","ref","useInsertionEffect","dataset","motionPopId","style","document","createElement","head","appendChild","sheet","insertRule","removeChild","PresenceChild","initial","onExitComplete","custom","presenceAffectsLayout","mode","presenceChildren","newChildrenMap","context","useMemo","childId","set","isComplete","values","register","delete","undefined","forEach","_","key","PresenceContext","Provider","value","Map","getChildKey","child","AnimatePresence","exitBeforeEnter","forceRender","useContext","LayoutGroupContext","forcedRenderCount","setForcedRenderCount","useState","useCallback","postRender","useForceUpdate","filteredChildren","filtered","Children","isValidElement","push","onlyElements","childrenToRender","exitingChildren","presentChildren","allChildren","isInitialRender","callback","updateChildLookup","clear","useEffect","map","presentKeys","targetKeys","numPresent","length","i","indexOf","has","component","get","insertionIndex","exitingComponent","onExit","leftOverKeys","Array","from","keys","filter","childKey","includes","leftOverKey","presentChild","presentChildKey","splice","cloneElement","useMotionValueEvent","event","on","resizeHandlers","WeakMap","observer","notifyTarget","target","contentRect","borderBoxSize","_a","handler","contentSize","inlineSize","blockSize","SVGElement","getBBox","getElementSize","notifyAll","entries","resizeElement","ResizeObserver","elements","scope","selectorCache","root","Boolean","querySelectorAll","Element","resolveElements","elementHandlers","Set","add","observe","unobserve","windowCallbacks","windowResizeHandler","resizeWindow","window","innerWidth","innerHeight","info","addEventListener","x","position","y","updateAxisInfo","axisName","time","axis","prev","prevTime","scrollLength","offset","progress","elapsed","velocity","ScrollOffset","Enter","Exit","Any","All","namedEdges","start","center","end","resolveEdge","edge","inset","delta","asNumber","parseFloat","endsWith","documentElement","clientWidth","clientHeight","defaultOffset","resolveOffset","containerLength","targetLength","targetInset","offsetDefinition","isArray","targetPoint","containerPoint","trim","split","point","resolveOffsets","container","options","lengthLabel","HTMLElement","offsetParent","tagName","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","SVGGraphicsElement","svg","parent","parentNode","calcInset","targetSize","scrollWidth","scrollHeight","getTargetSize","containerSize","hasChanged","interpolate","numOffsets","interpolatorOffsets","createOnScrollHandler","onScroll","measure","targetOffset","node","update","updateScrollInfo","notify","scrollListeners","resizeListeners","onScrollHandlers","getEventTarget","scrollInfo","containerHandlers","containerHandler","measureAll","updateAll","frameData","timestamp","listener","read","passive","b","a","currentHandlers","scrollListener","removeEventListener","refWarning","name","createScrollMotionValues","scrollX","scrollY","scrollXProgress","scrollYProgress","useScroll","layoutEffect","JSON","stringify"],"sourceRoot":""}