{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/reduce-css-calc/dist/lib/convert.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _cssUnitConverter = require('css-unit-converter');\n\nvar _cssUnitConverter2 = _interopRequireDefault(_cssUnitConverter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction convertNodes(left, right, precision) {\n  switch (left.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n      return convertAbsoluteLength(left, right, precision);\n    default:\n      return { left: left, right: right };\n  }\n}\n\nfunction convertAbsoluteLength(left, right, precision) {\n  if (right.type === left.type) {\n    right = {\n      type: left.type,\n      value: (0, _cssUnitConverter2.default)(right.value, right.unit, left.unit, precision),\n      unit: left.unit\n    };\n  }\n  return { left: left, right: right };\n}\n\nexports.default = convertNodes;\nmodule.exports = exports['default'];"],"names":[],"mappings":"AAAA;AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AAEA,IAAI,oBAAoB;AAExB,IAAI,qBAAqB,uBAAuB;AAEhD,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F,SAAS,aAAa,IAAI,EAAE,KAAK,EAAE,SAAS;IAC1C,OAAQ,KAAK,IAAI;QACf,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACH,OAAO,sBAAsB,MAAM,OAAO;QAC5C;YACE,OAAO;gBAAE,MAAM;gBAAM,OAAO;YAAM;IACtC;AACF;AAEA,SAAS,sBAAsB,IAAI,EAAE,KAAK,EAAE,SAAS;IACnD,IAAI,MAAM,IAAI,KAAK,KAAK,IAAI,EAAE;QAC5B,QAAQ;YACN,MAAM,KAAK,IAAI;YACf,OAAO,AAAC,CAAA,GAAG,mBAAmB,OAAO,AAAD,EAAG,MAAM,KAAK,EAAE,MAAM,IAAI,EAAE,KAAK,IAAI,EAAE;YAC3E,MAAM,KAAK,IAAI;QACjB;IACF;IACA,OAAO;QAAE,MAAM;QAAM,OAAO;IAAM;AACpC;AAEA,QAAQ,OAAO,GAAG;AAClB,OAAO,OAAO,GAAG,OAAO,CAAC,UAAU"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/reduce-css-calc/dist/lib/reducer.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flip = flip;\n\nvar _convert = require(\"./convert\");\n\nvar _convert2 = _interopRequireDefault(_convert);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction reduce(node, precision) {\n  if (node.type === \"MathExpression\") return reduceMathExpression(node, precision);\n  if (node.type === \"Calc\") return reduce(node.value, precision);\n\n  return node;\n}\n\nfunction isEqual(left, right) {\n  return left.type === right.type && left.value === right.value;\n}\n\nfunction isValueType(type) {\n  switch (type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n    case 'EmValue':\n    case 'ExValue':\n    case 'ChValue':\n    case 'RemValue':\n    case 'VhValue':\n    case 'VwValue':\n    case 'VminValue':\n    case 'VmaxValue':\n    case 'PercentageValue':\n    case 'Value':\n      return true;\n  }\n  return false;\n}\n\nfunction convertMathExpression(node, precision) {\n  var nodes = (0, _convert2.default)(node.left, node.right, precision);\n  var left = reduce(nodes.left, precision);\n  var right = reduce(nodes.right, precision);\n\n  if (left.type === \"MathExpression\" && right.type === \"MathExpression\") {\n\n    if (left.operator === '/' && right.operator === '*' || left.operator === '-' && right.operator === '+' || left.operator === '*' && right.operator === '/' || left.operator === '+' && right.operator === '-') {\n\n      if (isEqual(left.right, right.right)) nodes = (0, _convert2.default)(left.left, right.left, precision);else if (isEqual(left.right, right.left)) nodes = (0, _convert2.default)(left.left, right.right, precision);\n\n      left = reduce(nodes.left, precision);\n      right = reduce(nodes.right, precision);\n    }\n  }\n\n  node.left = left;\n  node.right = right;\n  return node;\n}\n\nfunction flip(operator) {\n  return operator === '+' ? '-' : '+';\n}\n\nfunction flipValue(node) {\n  if (isValueType(node.type)) node.value = -node.value;else if (node.type == 'MathExpression') {\n    node.left = flipValue(node.left);\n    node.right = flipValue(node.right);\n  }\n  return node;\n}\n\nfunction reduceAddSubExpression(node, precision) {\n  var _node = node,\n      left = _node.left,\n      right = _node.right,\n      op = _node.operator;\n\n\n  if (left.type === 'CssVariable' || right.type === 'CssVariable') return node;\n\n  // something + 0 => something\n  // something - 0 => something\n  if (right.value === 0) return left;\n\n  // 0 + something => something\n  if (left.value === 0 && op === \"+\") return right;\n\n  // 0 - something => -something\n  if (left.value === 0 && op === \"-\") return flipValue(right);\n\n  // value + value\n  // value - value\n  if (left.type === right.type && isValueType(left.type)) {\n    node = Object.assign({}, left);\n    if (op === \"+\") node.value = left.value + right.value;else node.value = left.value - right.value;\n  }\n\n  // value <op> (expr)\n  if (isValueType(left.type) && (right.operator === '+' || right.operator === '-') && right.type === 'MathExpression') {\n    // value + (value + something) => (value + value) + something\n    // value + (value - something) => (value + value) - something\n    // value - (value + something) => (value - value) - something\n    // value - (value - something) => (value - value) + something\n    if (left.type === right.left.type) {\n      node = Object.assign({}, node);\n      node.left = reduce({\n        type: 'MathExpression',\n        operator: op,\n        left: left,\n        right: right.left\n      }, precision);\n      node.right = right.right;\n      node.operator = op === '-' ? flip(right.operator) : right.operator;\n      return reduce(node, precision);\n    }\n    // value + (something + value) => (value + value) + something\n    // value + (something - value) => (value - value) + something\n    // value - (something + value) => (value - value) - something\n    // value - (something - value) => (value + value) - something\n    else if (left.type === right.right.type) {\n        node = Object.assign({}, node);\n        node.left = reduce({\n          type: 'MathExpression',\n          operator: op === '-' ? flip(right.operator) : right.operator,\n          left: left,\n          right: right.right\n        }, precision);\n        node.right = right.left;\n        return reduce(node, precision);\n      }\n  }\n\n  // (expr) <op> value\n  if (left.type === 'MathExpression' && (left.operator === '+' || left.operator === '-') && isValueType(right.type)) {\n    // (value + something) + value => (value + value) + something\n    // (value - something) + value => (value + value) - something\n    // (value + something) - value => (value - value) + something\n    // (value - something) - value => (value - value) - something\n    if (right.type === left.left.type) {\n      node = Object.assign({}, left);\n      node.left = reduce({\n        type: 'MathExpression',\n        operator: op,\n        left: left.left,\n        right: right\n      }, precision);\n      return reduce(node, precision);\n    }\n    // (something + value) + value => something + (value + value)\n    // (something - value1) + value2 => something - (value2 - value1)\n    // (something + value) - value => something + (value - value)\n    // (something - value) - value => something - (value + value)\n    else if (right.type === left.right.type) {\n        node = Object.assign({}, left);\n        if (left.operator === '-') {\n          node.right = reduce({\n            type: 'MathExpression',\n            operator: op === '-' ? '+' : '-',\n            left: right,\n            right: left.right\n          }, precision);\n          node.operator = op === '-' ? '-' : '+';\n        } else {\n          node.right = reduce({\n            type: 'MathExpression',\n            operator: op,\n            left: left.right,\n            right: right\n          }, precision);\n        }\n        if (node.right.value < 0) {\n          node.right.value *= -1;\n          node.operator = node.operator === '-' ? '+' : '-';\n        }\n        return reduce(node, precision);\n      }\n  }\n  return node;\n}\n\nfunction reduceDivisionExpression(node, precision) {\n  if (!isValueType(node.right.type)) return node;\n\n  if (node.right.type !== 'Value') throw new Error(\"Cannot divide by \\\"\" + node.right.unit + \"\\\", number expected\");\n\n  if (node.right.value === 0) throw new Error('Cannot divide by zero');\n\n  // (expr) / value\n  if (node.left.type === 'MathExpression') {\n    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {\n      node.left.left.value /= node.right.value;\n      node.left.right.value /= node.right.value;\n      return reduce(node.left, precision);\n    }\n    return node;\n  }\n  // something / value\n  else if (isValueType(node.left.type)) {\n      node.left.value /= node.right.value;\n      return node.left;\n    }\n  return node;\n}\n\nfunction reduceMultiplicationExpression(node) {\n  // (expr) * value\n  if (node.left.type === 'MathExpression' && node.right.type === 'Value') {\n    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {\n      node.left.left.value *= node.right.value;\n      node.left.right.value *= node.right.value;\n      return node.left;\n    }\n  }\n  // something * value\n  else if (isValueType(node.left.type) && node.right.type === 'Value') {\n      node.left.value *= node.right.value;\n      return node.left;\n    }\n    // value * (expr)\n    else if (node.left.type === 'Value' && node.right.type === 'MathExpression') {\n        if (isValueType(node.right.left.type) && isValueType(node.right.right.type)) {\n          node.right.left.value *= node.left.value;\n          node.right.right.value *= node.left.value;\n          return node.right;\n        }\n      }\n      // value * something\n      else if (node.left.type === 'Value' && isValueType(node.right.type)) {\n          node.right.value *= node.left.value;\n          return node.right;\n        }\n  return node;\n}\n\nfunction reduceMathExpression(node, precision) {\n  node = convertMathExpression(node, precision);\n\n  switch (node.operator) {\n    case \"+\":\n    case \"-\":\n      return reduceAddSubExpression(node, precision);\n    case \"/\":\n      return reduceDivisionExpression(node, precision);\n    case \"*\":\n      return reduceMultiplicationExpression(node);\n  }\n  return node;\n}\n\nexports.default = reduce;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 260, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/reduce-css-calc/dist/lib/stringifier.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (calc, node, precision) {\n  var str = stringify(node, precision);\n\n  if (node.type === \"MathExpression\") {\n    // if calc expression couldn't be resolved to a single value, re-wrap it as\n    // a calc()\n    str = calc + \"(\" + str + \")\";\n  }\n  return str;\n};\n\nvar _reducer = require(\"./reducer\");\n\nvar order = {\n  \"*\": 0,\n  \"/\": 0,\n  \"+\": 1,\n  \"-\": 1\n};\n\nfunction round(value, prec) {\n  if (prec !== false) {\n    var precision = Math.pow(10, prec);\n    return Math.round(value * precision) / precision;\n  }\n  return value;\n}\n\nfunction stringify(node, prec) {\n  switch (node.type) {\n    case \"MathExpression\":\n      {\n        var left = node.left,\n            right = node.right,\n            op = node.operator;\n\n        var str = \"\";\n\n        if (left.type === 'MathExpression' && order[op] < order[left.operator]) str += \"(\" + stringify(left, prec) + \")\";else str += stringify(left, prec);\n\n        str += \" \" + node.operator + \" \";\n\n        if (right.type === 'MathExpression' && order[op] < order[right.operator]) {\n          str += \"(\" + stringify(right, prec) + \")\";\n        } else if (right.type === 'MathExpression' && op === \"-\" && [\"+\", \"-\"].includes(right.operator)) {\n          // fix #52 : a-(b+c) = a-b-c\n          right.operator = (0, _reducer.flip)(right.operator);\n          str += stringify(right, prec);\n        } else {\n          str += stringify(right, prec);\n        }\n\n        return str;\n      }\n    case \"Value\":\n      return round(node.value, prec);\n    case 'CssVariable':\n      if (node.fallback) {\n        return \"var(\" + node.value + \", \" + stringify(node.fallback, prec, true) + \")\";\n      }\n      return \"var(\" + node.value + \")\";\n    case 'Calc':\n      if (node.prefix) {\n        return \"-\" + node.prefix + \"-calc(\" + stringify(node.value, prec) + \")\";\n      }\n      return \"calc(\" + stringify(node.value, prec) + \")\";\n    default:\n      return round(node.value, prec) + node.unit;\n  }\n}\n\nmodule.exports = exports[\"default\"];"],"names":[],"mappings":"AAAA;AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AAEA,QAAQ,OAAO,GAAG,SAAU,IAAI,EAAE,IAAI,EAAE,SAAS;IAC/C,IAAI,MAAM,UAAU,MAAM;IAE1B,IAAI,KAAK,IAAI,KAAK,kBAAkB;QAClC,2EAA2E;QAC3E,WAAW;QACX,MAAM,OAAO,MAAM,MAAM;IAC3B;IACA,OAAO;AACT;AAEA,IAAI,WAAW;AAEf,IAAI,QAAQ;IACV,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACP;AAEA,SAAS,MAAM,KAAK,EAAE,IAAI;IACxB,IAAI,SAAS,OAAO;QAClB,IAAI,YAAY,KAAK,GAAG,CAAC,IAAI;QAC7B,OAAO,KAAK,KAAK,CAAC,QAAQ,aAAa;IACzC;IACA,OAAO;AACT;AAEA,SAAS,UAAU,IAAI,EAAE,IAAI;IAC3B,OAAQ,KAAK,IAAI;QACf,KAAK;YACH;gBACE,IAAI,OAAO,KAAK,IAAI,EAChB,QAAQ,KAAK,KAAK,EAClB,KAAK,KAAK,QAAQ;gBAEtB,IAAI,MAAM;gBAEV,IAAI,KAAK,IAAI,KAAK,oBAAoB,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,QAAQ,CAAC,EAAE,OAAO,MAAM,UAAU,MAAM,QAAQ;qBAAS,OAAO,UAAU,MAAM;gBAE7I,OAAO,MAAM,KAAK,QAAQ,GAAG;gBAE7B,IAAI,MAAM,IAAI,KAAK,oBAAoB,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,MAAM,QAAQ,CAAC,EAAE;oBACxE,OAAO,MAAM,UAAU,OAAO,QAAQ;gBACxC,OAAO,IAAI,MAAM,IAAI,KAAK,oBAAoB,OAAO,OAAO;oBAAC;oBAAK;iBAAI,CAAC,QAAQ,CAAC,MAAM,QAAQ,GAAG;oBAC/F,4BAA4B;oBAC5B,MAAM,QAAQ,GAAG,AAAC,CAAA,GAAG,SAAS,IAAI,AAAD,EAAG,MAAM,QAAQ;oBAClD,OAAO,UAAU,OAAO;gBAC1B,OAAO;oBACL,OAAO,UAAU,OAAO;gBAC1B;gBAEA,OAAO;YACT;QACF,KAAK;YACH,OAAO,MAAM,KAAK,KAAK,EAAE;QAC3B,KAAK;YACH,IAAI,KAAK,QAAQ,EAAE;gBACjB,OAAO,SAAS,KAAK,KAAK,GAAG,OAAO,UAAU,KAAK,QAAQ,EAAE,MAAM,QAAQ;YAC7E;YACA,OAAO,SAAS,KAAK,KAAK,GAAG;QAC/B,KAAK;YACH,IAAI,KAAK,MAAM,EAAE;gBACf,OAAO,MAAM,KAAK,MAAM,GAAG,WAAW,UAAU,KAAK,KAAK,EAAE,QAAQ;YACtE;YACA,OAAO,UAAU,UAAU,KAAK,KAAK,EAAE,QAAQ;QACjD;YACE,OAAO,MAAM,KAAK,KAAK,EAAE,QAAQ,KAAK,IAAI;IAC9C;AACF;AAEA,OAAO,OAAO,GAAG,OAAO,CAAC,UAAU"}},
    {"offset": {"line": 331, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 335, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/reduce-css-calc/dist/parser.js"],"sourcesContent":["\n/* parser generated by jison 0.6.1-215 */\n\n/*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own 'description' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that's actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journées Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.\n *\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you're clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function's\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success ('accept')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\n\n        \n    \n            var parser = (function () {\n\n\n// See also:\n// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n// with userland code which might access the derived class in a 'classic' way.\nfunction JisonParserError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n        enumerable: false,\n        writable: false,\n        value: 'JisonParserError'\n    });\n\n    if (msg == null) msg = '???';\n\n    Object.defineProperty(this, 'message', {\n        enumerable: false,\n        writable: true,\n        value: msg\n    });\n\n    this.hash = hash;\n\n    var stacktrace;\n    if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n    }\n    if (!stacktrace) {\n        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            stacktrace = (new Error(msg)).stack;\n        }\n    }\n    if (stacktrace) {\n        Object.defineProperty(this, 'stack', {\n            enumerable: false,\n            writable: false,\n            value: stacktrace\n        });\n    }\n}\n\nif (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n} else {\n    JisonParserError.prototype = Object.create(Error.prototype);\n}\nJisonParserError.prototype.constructor = JisonParserError;\nJisonParserError.prototype.name = 'JisonParserError';\n\n\n\n\n        // helper: reconstruct the productions[] table\n        function bp(s) {\n            var rv = [];\n            var p = s.pop;\n            var r = s.rule;\n            for (var i = 0, l = p.length; i < l; i++) {\n                rv.push([\n                    p[i],\n                    r[i]\n                ]);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the defaultActions[] table\n        function bda(s) {\n            var rv = {};\n            var d = s.idx;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var j = d[i];\n                rv[j] = g[i];\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the 'goto' table\n        function bt(s) {\n            var rv = [];\n            var d = s.len;\n            var y = s.symbol;\n            var t = s.type;\n            var a = s.state;\n            var m = s.mode;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var n = d[i];\n                var q = {};\n                for (var j = 0; j < n; j++) {\n                    var z = y.shift();\n                    switch (t.shift()) {\n                    case 2:\n                        q[z] = [\n                            m.shift(),\n                            g.shift()\n                        ];\n                        break;\n\n                    case 0:\n                        q[z] = a.shift();\n                        break;\n\n                    default:\n                        // type === 1: accept\n                        q[z] = [\n                            3\n                        ];\n                    }\n                }\n                rv.push(q);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: runlength encoding with increment step: code, length: step (default step = 0)\n        // `this` references an array\n        function s(c, l, a) {\n            a = a || 0;\n            for (var i = 0; i < l; i++) {\n                this.push(c);\n                c += a;\n            }\n        }\n\n        // helper: duplicate sequence from *relative* offset and length.\n        // `this` references an array\n        function c(i, l) {\n            i = this.length - i;\n            for (l += i; i < l; i++) {\n                this.push(this[i]);\n            }\n        }\n\n        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n        function u(a) {\n            var rv = [];\n            for (var i = 0, l = a.length; i < l; i++) {\n                var e = a[i];\n                // Is this entry a helper function?\n                if (typeof e === 'function') {\n                    i++;\n                    e.apply(rv, a[i]);\n                } else {\n                    rv.push(e);\n                }\n            }\n            return rv;\n        }\n    \n\nvar parser = {\n    // Code Generator Information Report\n    // ---------------------------------\n    //\n    // Options:\n    //\n    //   default action mode: ............. [\"classic\",\"merge\"]\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\n    //   try..catch: ...................... true\n    //   default resolve on conflict: ..... true\n    //   on-demand look-ahead: ............ false\n    //   error recovery token skip maximum: 3\n    //   yyerror in parse actions is: ..... NOT recoverable,\n    //   yyerror in lexer actions and other non-fatal lexer are:\n    //   .................................. NOT recoverable,\n    //   debug grammar/output: ............ false\n    //   has partial LR conflict upgrade:   true\n    //   rudimentary token-stack support:   false\n    //   parser table compression mode: ... 2\n    //   export debug tables: ............. false\n    //   export *all* tables: ............. false\n    //   module type: ..................... commonjs\n    //   parser engine type: .............. lalr\n    //   output main() in the module: ..... true\n    //   has user-specified main(): ....... false\n    //   has user-specified require()/import modules for main():\n    //   .................................. false\n    //   number of expected conflicts: .... 0\n    //\n    //\n    // Parser Analysis flags:\n    //\n    //   no significant actions (parser is a language matcher only):\n    //   .................................. false\n    //   uses yyleng: ..................... false\n    //   uses yylineno: ................... false\n    //   uses yytext: ..................... false\n    //   uses yylloc: ..................... false\n    //   uses ParseError API: ............. false\n    //   uses YYERROR: .................... false\n    //   uses YYRECOVERING: ............... false\n    //   uses YYERROK: .................... false\n    //   uses YYCLEARIN: .................. false\n    //   tracks rule values: .............. true\n    //   assigns rule values: ............. true\n    //   uses location tracking: .......... false\n    //   assigns location: ................ false\n    //   uses yystack: .................... false\n    //   uses yysstack: ................... false\n    //   uses yysp: ....................... true\n    //   uses yyrulelength: ............... false\n    //   uses yyMergeLocationInfo API: .... false\n    //   has error recovery: .............. false\n    //   has error reporting: ............. false\n    //\n    // --------- END OF REPORT -----------\n\ntrace: function no_op_trace() { },\nJisonParserError: JisonParserError,\nyy: {},\noptions: {\n  type: \"lalr\",\n  hasPartialLrUpgradeOnConflict: true,\n  errorRecoveryTokenDiscardCount: 3\n},\nsymbols_: {\n  \"$accept\": 0,\n  \"$end\": 1,\n  \"ADD\": 3,\n  \"ANGLE\": 16,\n  \"CHS\": 22,\n  \"COMMA\": 14,\n  \"CSS_CPROP\": 13,\n  \"CSS_VAR\": 12,\n  \"DIV\": 6,\n  \"EMS\": 20,\n  \"EOF\": 1,\n  \"EXS\": 21,\n  \"FREQ\": 18,\n  \"LENGTH\": 15,\n  \"LPAREN\": 7,\n  \"MUL\": 5,\n  \"NESTED_CALC\": 9,\n  \"NUMBER\": 11,\n  \"PERCENTAGE\": 28,\n  \"PREFIX\": 10,\n  \"REMS\": 23,\n  \"RES\": 19,\n  \"RPAREN\": 8,\n  \"SUB\": 4,\n  \"TIME\": 17,\n  \"VHS\": 24,\n  \"VMAXS\": 27,\n  \"VMINS\": 26,\n  \"VWS\": 25,\n  \"css_value\": 33,\n  \"css_variable\": 32,\n  \"error\": 2,\n  \"expression\": 29,\n  \"math_expression\": 30,\n  \"value\": 31\n},\nterminals_: {\n  1: \"EOF\",\n  2: \"error\",\n  3: \"ADD\",\n  4: \"SUB\",\n  5: \"MUL\",\n  6: \"DIV\",\n  7: \"LPAREN\",\n  8: \"RPAREN\",\n  9: \"NESTED_CALC\",\n  10: \"PREFIX\",\n  11: \"NUMBER\",\n  12: \"CSS_VAR\",\n  13: \"CSS_CPROP\",\n  14: \"COMMA\",\n  15: \"LENGTH\",\n  16: \"ANGLE\",\n  17: \"TIME\",\n  18: \"FREQ\",\n  19: \"RES\",\n  20: \"EMS\",\n  21: \"EXS\",\n  22: \"CHS\",\n  23: \"REMS\",\n  24: \"VHS\",\n  25: \"VWS\",\n  26: \"VMINS\",\n  27: \"VMAXS\",\n  28: \"PERCENTAGE\"\n},\nTERROR: 2,\n    EOF: 1,\n\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n    // thus helping JIT compilers like Chrome V8.\n    originalQuoteName: null,\n    originalParseError: null,\n    cleanupAfterParse: null,\n    constructParseErrorInfo: null,\n    yyMergeLocationInfo: null,\n\n    __reentrant_call_depth: 0,      // INTERNAL USE ONLY\n    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n\n    // APIs which will be set up depending on user action code analysis:\n    //yyRecovering: 0,\n    //yyErrOk: 0,\n    //yyClearIn: 0,\n\n    // Helper APIs\n    // -----------\n\n    // Helper function which can be overridden by user code later on: put suitable quotes around\n    // literal IDs in a description string.\n    quoteName: function parser_quoteName(id_str) {\n        return '\"' + id_str + '\"';\n    },\n\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    getSymbolName: function parser_getSymbolName(symbol) {\n        if (this.terminals_[symbol]) {\n            return this.terminals_[symbol];\n        }\n\n        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n        //\n        // An example of this may be where a rule's action code contains a call like this:\n        //\n        //      parser.getSymbolName(#$)\n        //\n        // to obtain a human-readable name of the current grammar rule.\n        var s = this.symbols_;\n        for (var key in s) {\n            if (s[key] === symbol) {\n                return key;\n            }\n        }\n        return null;\n    },\n\n    // Return a more-or-less human-readable description of the given symbol, when available,\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    describeSymbol: function parser_describeSymbol(symbol) {\n        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n            return this.terminal_descriptions_[symbol];\n        }\n        else if (symbol === this.EOF) {\n            return 'end of input';\n        }\n        var id = this.getSymbolName(symbol);\n        if (id) {\n            return this.quoteName(id);\n        }\n        return null;\n    },\n\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n    //\n    // The produced list may contain token or token set descriptions instead of the tokens\n    // themselves to help turning this output into something that easier to read by humans\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n    // expected terminals and nonterminals is produced.\n    //\n    // The returned list (array) will not contain any duplicate entries.\n    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n        var TERROR = this.TERROR;\n        var tokenset = [];\n        var check = {};\n        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n        // If so, use that one instead of the less palatable token set.\n        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n            return [\n                this.state_descriptions_[state]\n            ];\n        }\n        for (var p in this.table[state]) {\n            p = +p;\n            if (p !== TERROR) {\n                var d = do_not_describe ? p : this.describeSymbol(p);\n                if (d && !check[d]) {\n                    tokenset.push(d);\n                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.\n                }\n            }\n        }\n        return tokenset;\n    },\nproductions_: bp({\n  pop: u([\n  29,\n  s,\n  [30, 10],\n  31,\n  31,\n  32,\n  32,\n  s,\n  [33, 15]\n]),\n  rule: u([\n  2,\n  s,\n  [3, 5],\n  4,\n  7,\n  s,\n  [1, 4],\n  2,\n  4,\n  6,\n  s,\n  [1, 14],\n  2\n])\n}),\nperformAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {\n\n          /* this == yyval */\n\n          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n          var yy = this.yy;\n          var yyparser = yy.parser;\n          var yylexer = yy.lexer;\n\n          \n\n          switch (yystate) {\ncase 0:\n    /*! Production::    $accept : expression $end */\n\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):\n    this.$ = yyvstack[yysp - 1];\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)\n    break;\n\ncase 1:\n    /*! Production::    expression : math_expression EOF */\n\n    // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):\n    this.$ = yyvstack[yysp - 1];\n    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)\n    \n    \n    return yyvstack[yysp - 1];\n    break;\n\ncase 2:\n    /*! Production::    math_expression : math_expression ADD math_expression */\ncase 3:\n    /*! Production::    math_expression : math_expression SUB math_expression */\ncase 4:\n    /*! Production::    math_expression : math_expression MUL math_expression */\ncase 5:\n    /*! Production::    math_expression : math_expression DIV math_expression */\n\n    this.$ = { type: 'MathExpression', operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp] };\n    break;\n\ncase 6:\n    /*! Production::    math_expression : LPAREN math_expression RPAREN */\n\n    this.$ = yyvstack[yysp - 1];\n    break;\n\ncase 7:\n    /*! Production::    math_expression : NESTED_CALC LPAREN math_expression RPAREN */\n\n    this.$ = { type: 'Calc', value: yyvstack[yysp - 1] };\n    break;\n\ncase 8:\n    /*! Production::    math_expression : SUB PREFIX SUB NESTED_CALC LPAREN math_expression RPAREN */\n\n    this.$ = { type: 'Calc', value: yyvstack[yysp - 1], prefix: yyvstack[yysp - 5] };\n    break;\n\ncase 9:\n    /*! Production::    math_expression : css_variable */\ncase 10:\n    /*! Production::    math_expression : css_value */\ncase 11:\n    /*! Production::    math_expression : value */\n\n    this.$ = yyvstack[yysp];\n    break;\n\ncase 12:\n    /*! Production::    value : NUMBER */\n\n    this.$ = { type: 'Value', value: parseFloat(yyvstack[yysp]) };\n    break;\n\ncase 13:\n    /*! Production::    value : SUB NUMBER */\n\n    this.$ = { type: 'Value', value: parseFloat(yyvstack[yysp]) * -1 };\n    break;\n\ncase 14:\n    /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP RPAREN */\n\n    this.$ = { type: 'CssVariable', value: yyvstack[yysp - 1] };\n    break;\n\ncase 15:\n    /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP COMMA math_expression RPAREN */\n\n    this.$ = { type: 'CssVariable', value: yyvstack[yysp - 3], fallback: yyvstack[yysp - 1] };\n    break;\n\ncase 16:\n    /*! Production::    css_value : LENGTH */\n\n    this.$ = { type: 'LengthValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };\n    break;\n\ncase 17:\n    /*! Production::    css_value : ANGLE */\n\n    this.$ = { type: 'AngleValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };\n    break;\n\ncase 18:\n    /*! Production::    css_value : TIME */\n\n    this.$ = { type: 'TimeValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };\n    break;\n\ncase 19:\n    /*! Production::    css_value : FREQ */\n\n    this.$ = { type: 'FrequencyValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };\n    break;\n\ncase 20:\n    /*! Production::    css_value : RES */\n\n    this.$ = { type: 'ResolutionValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };\n    break;\n\ncase 21:\n    /*! Production::    css_value : EMS */\n\n    this.$ = { type: 'EmValue', value: parseFloat(yyvstack[yysp]), unit: 'em' };\n    break;\n\ncase 22:\n    /*! Production::    css_value : EXS */\n\n    this.$ = { type: 'ExValue', value: parseFloat(yyvstack[yysp]), unit: 'ex' };\n    break;\n\ncase 23:\n    /*! Production::    css_value : CHS */\n\n    this.$ = { type: 'ChValue', value: parseFloat(yyvstack[yysp]), unit: 'ch' };\n    break;\n\ncase 24:\n    /*! Production::    css_value : REMS */\n\n    this.$ = { type: 'RemValue', value: parseFloat(yyvstack[yysp]), unit: 'rem' };\n    break;\n\ncase 25:\n    /*! Production::    css_value : VHS */\n\n    this.$ = { type: 'VhValue', value: parseFloat(yyvstack[yysp]), unit: 'vh' };\n    break;\n\ncase 26:\n    /*! Production::    css_value : VWS */\n\n    this.$ = { type: 'VwValue', value: parseFloat(yyvstack[yysp]), unit: 'vw' };\n    break;\n\ncase 27:\n    /*! Production::    css_value : VMINS */\n\n    this.$ = { type: 'VminValue', value: parseFloat(yyvstack[yysp]), unit: 'vmin' };\n    break;\n\ncase 28:\n    /*! Production::    css_value : VMAXS */\n\n    this.$ = { type: 'VmaxValue', value: parseFloat(yyvstack[yysp]), unit: 'vmax' };\n    break;\n\ncase 29:\n    /*! Production::    css_value : PERCENTAGE */\n\n    this.$ = { type: 'PercentageValue', value: parseFloat(yyvstack[yysp]), unit: '%' };\n    break;\n\ncase 30:\n    /*! Production::    css_value : SUB css_value */\n\n    var prev = yyvstack[yysp]; prev.value *= -1; this.$ = prev;\n    break;\n\n}\n},\ntable: bt({\n  len: u([\n  24,\n  1,\n  5,\n  23,\n  1,\n  18,\n  s,\n  [0, 3],\n  1,\n  s,\n  [0, 16],\n  s,\n  [23, 4],\n  c,\n  [28, 3],\n  0,\n  0,\n  16,\n  1,\n  6,\n  6,\n  s,\n  [0, 3],\n  5,\n  1,\n  2,\n  c,\n  [37, 3],\n  c,\n  [20, 3],\n  5,\n  0,\n  0\n]),\n  symbol: u([\n  4,\n  7,\n  9,\n  11,\n  12,\n  s,\n  [15, 19, 1],\n  1,\n  1,\n  s,\n  [3, 4, 1],\n  c,\n  [30, 19],\n  c,\n  [29, 4],\n  7,\n  4,\n  10,\n  11,\n  c,\n  [22, 14],\n  c,\n  [19, 3],\n  c,\n  [43, 22],\n  c,\n  [23, 69],\n  c,\n  [139, 4],\n  8,\n  c,\n  [51, 24],\n  4,\n  c,\n  [138, 15],\n  13,\n  c,\n  [186, 5],\n  8,\n  c,\n  [6, 6],\n  c,\n  [5, 5],\n  9,\n  8,\n  14,\n  c,\n  [159, 47],\n  c,\n  [60, 10]\n]),\n  type: u([\n  s,\n  [2, 19],\n  s,\n  [0, 5],\n  1,\n  s,\n  [2, 24],\n  s,\n  [0, 4],\n  c,\n  [22, 19],\n  c,\n  [43, 42],\n  c,\n  [23, 70],\n  c,\n  [28, 25],\n  c,\n  [45, 25],\n  c,\n  [113, 54]\n]),\n  state: u([\n  1,\n  2,\n  8,\n  6,\n  7,\n  30,\n  c,\n  [4, 3],\n  33,\n  37,\n  c,\n  [5, 3],\n  38,\n  c,\n  [4, 3],\n  39,\n  c,\n  [4, 3],\n  40,\n  c,\n  [4, 3],\n  42,\n  c,\n  [21, 4],\n  50,\n  c,\n  [5, 3],\n  51,\n  c,\n  [4, 3]\n]),\n  mode: u([\n  s,\n  [1, 179],\n  s,\n  [2, 3],\n  c,\n  [5, 5],\n  c,\n  [6, 4],\n  s,\n  [1, 57]\n]),\n  goto: u([\n  5,\n  3,\n  4,\n  24,\n  s,\n  [9, 15, 1],\n  s,\n  [25, 5, 1],\n  c,\n  [24, 19],\n  31,\n  35,\n  32,\n  34,\n  c,\n  [18, 14],\n  36,\n  c,\n  [38, 19],\n  c,\n  [19, 57],\n  c,\n  [118, 4],\n  41,\n  c,\n  [24, 19],\n  43,\n  35,\n  c,\n  [16, 14],\n  44,\n  s,\n  [2, 3],\n  28,\n  29,\n  2,\n  s,\n  [3, 3],\n  28,\n  29,\n  3,\n  c,\n  [53, 4],\n  s,\n  [45, 5, 1],\n  c,\n  [100, 42],\n  52,\n  c,\n  [5, 4],\n  53\n])\n}),\ndefaultActions: bda({\n  idx: u([\n  6,\n  7,\n  8,\n  s,\n  [10, 16, 1],\n  33,\n  34,\n  39,\n  40,\n  41,\n  45,\n  47,\n  52,\n  53\n]),\n  goto: u([\n  9,\n  10,\n  11,\n  s,\n  [16, 14, 1],\n  12,\n  1,\n  30,\n  13,\n  s,\n  [4, 4, 1],\n  14,\n  15,\n  8\n])\n}),\nparseError: function parseError(str, hash, ExceptionClass) {\n    if (hash.recoverable) {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        hash.destroy();             // destroy... well, *almost*!\n    } else {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        if (!ExceptionClass) {\n            ExceptionClass = this.JisonParserError;\n        }\n        throw new ExceptionClass(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this;\n    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)\n    var sstack = new Array(128);        // state stack: stores states (column storage)\n\n    var vstack = new Array(128);        // semantic value stack\n\n    var table = this.table;\n    var sp = 0;                         // 'stack pointer': index into the stacks\n\n\n    \n\n\n    var symbol = 0;\n\n\n\n    var TERROR = this.TERROR;\n    var EOF = this.EOF;\n    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;\n    var NO_ACTION = [0, 54 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];\n\n    var lexer;\n    if (this.__lexer__) {\n        lexer = this.__lexer__;\n    } else {\n        lexer = this.__lexer__ = Object.create(this.lexer);\n    }\n\n    var sharedState_yy = {\n        parseError: undefined,\n        quoteName: undefined,\n        lexer: undefined,\n        parser: undefined,\n        pre_parse: undefined,\n        post_parse: undefined,\n        pre_lex: undefined,\n        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n    };\n\n    var ASSERT;\n    if (typeof assert !== 'function') {\n        ASSERT = function JisonAssert(cond, msg) {\n            if (!cond) {\n                throw new Error('assertion failed: ' + (msg || '***'));\n            }\n        };\n    } else {\n        ASSERT = assert;\n    }\n\n    this.yyGetSharedState = function yyGetSharedState() {\n        return sharedState_yy;\n    };\n\n\n\n\n\n\n\n\n    function shallow_copy_noclobber(dst, src) {\n        for (var k in src) {\n            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {\n                dst[k] = src[k];\n            }\n        }\n    }\n\n    // copy state\n    shallow_copy_noclobber(sharedState_yy, this.yy);\n\n    sharedState_yy.lexer = lexer;\n    sharedState_yy.parser = this;\n\n\n\n\n\n\n    // Does the shared state override the default `parseError` that already comes with this instance?\n    if (typeof sharedState_yy.parseError === 'function') {\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n            if (!ExceptionClass) {\n                ExceptionClass = this.JisonParserError;\n            }\n            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n        };\n    } else {\n        this.parseError = this.originalParseError;\n    }\n\n    // Does the shared state override the default `quoteName` that already comes with this instance?\n    if (typeof sharedState_yy.quoteName === 'function') {\n        this.quoteName = function quoteNameAlt(id_str) {\n            return sharedState_yy.quoteName.call(this, id_str);\n        };\n    } else {\n        this.quoteName = this.originalQuoteName;\n    }\n\n    // set up the cleanup function; make it an API so that external code can re-use this one in case of\n    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n    // case this parse() API method doesn't come with a `finally { ... }` block any more!\n    //\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `sharedState`, etc. references will be *wrong*!\n    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n        var rv;\n\n        if (invoke_post_methods) {\n            var hash;\n\n            if (sharedState_yy.post_parse || this.post_parse) {\n                // create an error hash info instance: we re-use this API in a **non-error situation**\n                // as this one delivers all parser internals ready for access by userland code.\n                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);\n            }\n\n            if (sharedState_yy.post_parse) {\n                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n            if (this.post_parse) {\n                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n\n            // cleanup:\n            if (hash && hash.destroy) {\n                hash.destroy();\n            }\n        }\n\n        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.\n\n        // clean up the lingering lexer structures as well:\n        if (lexer.cleanupAfterLex) {\n            lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n        }\n\n        // prevent lingering circular references from causing memory leaks:\n        if (sharedState_yy) {\n            sharedState_yy.lexer = undefined;\n            sharedState_yy.parser = undefined;\n            if (lexer.yy === sharedState_yy) {\n                lexer.yy = undefined;\n            }\n        }\n        sharedState_yy = undefined;\n        this.parseError = this.originalParseError;\n        this.quoteName = this.originalQuoteName;\n\n        // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n        // To be safe, we nuke the other internal stack columns as well...\n        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC\n        sstack.length = 0;\n\n        vstack.length = 0;\n        sp = 0;\n\n        // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n        if (!do_not_nuke_errorinfos) {\n            for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n                var el = this.__error_infos[i];\n                if (el && typeof el.destroy === 'function') {\n                    el.destroy();\n                }\n            }\n            this.__error_infos.length = 0;\n\n\n        }\n\n        return resultValue;\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n        var pei = {\n            errStr: msg,\n            exception: ex,\n            text: lexer.match,\n            value: lexer.yytext,\n            token: this.describeSymbol(symbol) || symbol,\n            token_id: symbol,\n            line: lexer.yylineno,\n\n            expected: expected,\n            recoverable: recoverable,\n            state: state,\n            action: action,\n            new_state: newState,\n            symbol_stack: stack,\n            state_stack: sstack,\n            value_stack: vstack,\n\n            stack_pointer: sp,\n            yy: sharedState_yy,\n            lexer: lexer,\n            parser: this,\n\n            // and make sure the error info doesn't stay due to potential\n            // ref cycle via userland code manipulations.\n            // These would otherwise all be memory leak opportunities!\n            //\n            // Note that only array and object references are nuked as those\n            // constitute the set of elements which can produce a cyclic ref.\n            // The rest of the members is kept intact as they are harmless.\n            destroy: function destructParseErrorInfo() {\n                // remove cyclic references added to error info:\n                // info.yy = null;\n                // info.lexer = null;\n                // info.value = null;\n                // info.value_stack = null;\n                // ...\n                var rec = !!this.recoverable;\n                for (var key in this) {\n                    if (this.hasOwnProperty(key) && typeof key === 'object') {\n                        this[key] = undefined;\n                    }\n                }\n                this.recoverable = rec;\n            }\n        };\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n        this.__error_infos.push(pei);\n        return pei;\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n    function getNonTerminalFromCode(symbol) {\n        var tokenName = self.getSymbolName(symbol);\n        if (!tokenName) {\n            tokenName = symbol;\n        }\n        return tokenName;\n    }\n\n\n    function stdLex() {\n        var token = lexer.lex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    function fastLex() {\n        var token = lexer.fastLex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    var lex = stdLex;\n\n\n    var state, action, r, t;\n    var yyval = {\n        $: true,\n        _$: undefined,\n        yy: sharedState_yy\n    };\n    var p;\n    var yyrulelen;\n    var this_production;\n    var newState;\n    var retval = false;\n\n\n    try {\n        this.__reentrant_call_depth++;\n\n        lexer.setInput(input, sharedState_yy);\n\n        // NOTE: we *assume* no lexer pre/post handlers are set up *after* \n        // this initial `setInput()` call: hence we can now check and decide\n        // whether we'll go with the standard, slower, lex() API or the\n        // `fast_lex()` one:\n        if (typeof lexer.canIUse === 'function') {\n            var lexerInfo = lexer.canIUse();\n            if (lexerInfo.fastLex && typeof fastLex === 'function') {\n                lex = fastLex;\n            }\n        } \n\n\n\n        vstack[sp] = null;\n        sstack[sp] = 0;\n        stack[sp] = 0;\n        ++sp;\n\n\n\n\n\n        if (this.pre_parse) {\n            this.pre_parse.call(this, sharedState_yy);\n        }\n        if (sharedState_yy.pre_parse) {\n            sharedState_yy.pre_parse.call(this, sharedState_yy);\n        }\n\n        newState = sstack[sp - 1];\n        for (;;) {\n            // retrieve state number from top of stack\n            state = newState;               // sstack[sp - 1];\n\n            // use default actions if available\n            if (this.defaultActions[state]) {\n                action = 2;\n                newState = this.defaultActions[state];\n            } else {\n                // The single `==` condition below covers both these `===` comparisons in a single\n                // operation:\n                //\n                //     if (symbol === null || typeof symbol === 'undefined') ...\n                if (!symbol) {\n                    symbol = lex();\n                }\n                // read action for current state and first input\n                t = (table[state] && table[state][symbol]) || NO_ACTION;\n                newState = t[1];\n                action = t[0];\n\n\n\n\n\n\n\n\n\n\n\n                // handle parse error\n                if (!action) {\n                    var errStr;\n                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);\n                    var expected = this.collect_expected_token_set(state);\n\n                    // Report error\n                    if (typeof lexer.yylineno === 'number') {\n                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';\n                    } else {\n                        errStr = 'Parse error: ';\n                    }\n                    if (typeof lexer.showPosition === 'function') {\n                        errStr += '\\n' + lexer.showPosition(79 - 10, 10) + '\\n';\n                    }\n                    if (expected.length) {\n                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;\n                    } else {\n                        errStr += 'Unexpected ' + errSymbolDescr;\n                    }\n                    // we cannot recover from the error!\n                    p = this.constructParseErrorInfo(errStr, null, expected, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n\n\n            }\n\n\n\n\n\n\n\n\n\n\n            switch (action) {\n            // catch misc. parse failures:\n            default:\n                // this shouldn't happen, unless resolve defaults are off\n                if (action instanceof Array) {\n                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n                // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n                // or a buggy LUT (LookUp Table):\n                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                }\n                break;\n\n            // shift:\n            case 1:\n                stack[sp] = symbol;\n                vstack[sp] = lexer.yytext;\n\n                sstack[sp] = newState; // push state\n\n                ++sp;\n                symbol = 0;\n\n\n\n\n                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\n\n\n\n\n                continue;\n\n            // reduce:\n            case 2:\n\n\n\n                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                yyrulelen = this_production[1];\n\n\n\n\n\n\n\n\n\n\n                r = this.performAction.call(yyval, newState, sp - 1, vstack);\n\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                    break;\n                }\n\n                // pop off stack\n                sp -= yyrulelen;\n\n                // don't overwrite the `symbol` variable: use a local var to speed things up:\n                var ntsymbol = this_production[0];    // push nonterminal (reduce)\n                stack[sp] = ntsymbol;\n                vstack[sp] = yyval.$;\n\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[sstack[sp - 1]][ntsymbol];\n                sstack[sp] = newState;\n                ++sp;\n\n\n\n\n\n\n\n\n\n                continue;\n\n            // accept:\n            case 3:\n                if (sp !== -2) {\n                    retval = true;\n                    // Return the `$accept` rule's `$$` result, if available.\n                    //\n                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                    // default, action):\n                    //\n                    //     $accept: <startSymbol> $end\n                    //                  %{ $$ = $1; @$ = @1; %}\n                    //\n                    // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                    //\n                    // In code:\n                    //\n                    //                  %{\n                    //                      @$ = @1;            // if location tracking support is included\n                    //                      if (typeof $1 !== 'undefined')\n                    //                          return $1;\n                    //                      else\n                    //                          return true;           // the default parse result if the rule actions don't produce anything\n                    //                  %}\n                    sp--;\n                    if (typeof vstack[sp] !== 'undefined') {\n                        retval = vstack[sp];\n                    }\n                }\n                break;\n            }\n\n            // break out of loop: we accept or fail with error\n            break;\n        }\n    } catch (ex) {\n        // report exceptions through the parseError callback too, but keep the exception intact\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\n        if (ex instanceof this.JisonParserError) {\n            throw ex;\n        }\n        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {\n            throw ex;\n        }\n\n        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);\n        retval = false;\n        r = this.parseError(p.errStr, p, this.JisonParserError);\n        if (typeof r !== 'undefined') {\n            retval = r;\n        }\n    } finally {\n        retval = this.cleanupAfterParse(retval, true, true);\n        this.__reentrant_call_depth--;\n    }   // /finally\n\n    return retval;\n}\n};\nparser.originalParseError = parser.parseError;\nparser.originalQuoteName = parser.quoteName;\n/* lexer generated by jison-lex 0.6.1-215 */\n\n/*\n * Returns a Lexer object of the following structure:\n *\n *  Lexer: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a direct reference!\n *\n *               This \"shared context\" object was passed to the lexer by way of \n *               the `lexer.setInput(str, yy)` API before you may use it.\n *\n *               This \"shared context\" object is passed to the lexer action code in `performAction()`\n *               so userland code in the lexer actions may communicate with the outside world \n *               and/or other lexer rules' actions in more or less complex ways.\n *\n *  }\n *\n *  Lexer.prototype: {\n *    EOF: 1,\n *    ERROR: 2,\n *\n *    yy:        The overall \"shared context\" object reference.\n *\n *    JisonLexerError: function(msg, hash),\n *\n *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `lexer` instance. \n *                               `yy_` is an alias for `this` lexer instance reference used internally.\n *\n *               - `yy`      : a reference to the `yy` \"shared state\" object which was passed to the lexer\n *                             by way of the `lexer.setInput(str, yy)` API before.\n *\n *                             Note:\n *                             The extra arguments you specified in the `%parse-param` statement in your\n *                             **parser** grammar definition file are passed to the lexer via this object\n *                             reference as member variables.\n *\n *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.\n *\n *               - `YY_START`: the current lexer \"start condition\" state.\n *\n *    parseError: function(str, hash, ExceptionClass),\n *\n *    constructLexErrorInfo: function(error_message, is_recoverable),\n *               Helper function.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this lexer kernel in many places; example usage:\n *\n *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);\n *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);\n *\n *    options: { ... lexer %options ... },\n *\n *    lex: function(),\n *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the **parser** or the jison run-time; \n *               when such a collision is detected an exception is thrown to prevent the generated run-time \n *               from silently accepting this confusing and potentially hazardous situation! \n *\n *    cleanupAfterLex: function(do_not_nuke_errorinfos),\n *               Helper function.\n *\n *               This helper API is invoked when the **parse process** has completed: it is the responsibility\n *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. \n *\n *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.\n *\n *    setInput: function(input, [yy]),\n *\n *\n *    input: function(),\n *\n *\n *    unput: function(str),\n *\n *\n *    more: function(),\n *\n *\n *    reject: function(),\n *\n *\n *    less: function(n),\n *\n *\n *    pastInput: function(n),\n *\n *\n *    upcomingInput: function(n),\n *\n *\n *    showPosition: function(),\n *\n *\n *    test_match: function(regex_match_array, rule_index),\n *\n *\n *    next: function(),\n *\n *\n *    begin: function(condition),\n *\n *\n *    pushState: function(condition),\n *\n *\n *    popState: function(),\n *\n *\n *    topState: function(),\n *\n *\n *    _currentRules: function(),\n *\n *\n *    stateStackSize: function(),\n *\n *\n *    performAction: function(yy, yy_, yyrulenumber, YY_START),\n *\n *\n *    rules: [...],\n *\n *\n *    conditions: {associative list: name ==> set},\n *  }\n *\n *\n *  token location info (`yylloc`): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *  }\n *\n * while `this` will reference the current lexer instance.\n *\n * When `parseError` is invoked by the lexer, the default implementation will\n * attempt to invoke `yy.parser.parseError()`; when this callback is not provided\n * it will try to invoke `yy.parseError()` instead. When that callback is also not\n * provided, a `JisonLexerError` exception will be thrown containing the error\n * message and `hash`, as constructed by the `constructLexErrorInfo()` API.\n *\n * Note that the lexer's `JisonLexerError` error class is passed via the\n * `ExceptionClass` argument, which is invoked to construct the exception\n * instance to be thrown, so technically `parseError` will throw the object\n * produced by the `new ExceptionClass(str, hash)` JavaScript expression.\n *\n * ---\n *\n * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.\n * These options are available:\n *\n * (Options are permanent.)\n *  \n *  yy: {\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *  }\n *\n *  lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n * WARNING: the next set of options are not meant to be changed. They echo the abilities of\n * the lexer as per when it was compiled!\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\n\n\nvar lexer = function() {\n  /**\n   * See also:\n   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n   * with userland code which might access the derived class in a 'classic' way.\n   *\n   * @public\n   * @constructor\n   * @nocollapse\n   */\n  function JisonLexerError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n      enumerable: false,\n      writable: false,\n      value: 'JisonLexerError'\n    });\n\n    if (msg == null)\n      msg = '???';\n\n    Object.defineProperty(this, 'message', {\n      enumerable: false,\n      writable: true,\n      value: msg\n    });\n\n    this.hash = hash;\n    var stacktrace;\n\n    if (hash && hash.exception instanceof Error) {\n      var ex2 = hash.exception;\n      this.message = ex2.message || msg;\n      stacktrace = ex2.stack;\n    }\n\n    if (!stacktrace) {\n      if (Error.hasOwnProperty('captureStackTrace')) {\n        // V8\n        Error.captureStackTrace(this, this.constructor);\n      } else {\n        stacktrace = new Error(msg).stack;\n      }\n    }\n\n    if (stacktrace) {\n      Object.defineProperty(this, 'stack', {\n        enumerable: false,\n        writable: false,\n        value: stacktrace\n      });\n    }\n  }\n\n  if (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);\n  } else {\n    JisonLexerError.prototype = Object.create(Error.prototype);\n  }\n\n  JisonLexerError.prototype.constructor = JisonLexerError;\n  JisonLexerError.prototype.name = 'JisonLexerError';\n\n  var lexer = {\n    \n// Code Generator Information Report\n// ---------------------------------\n//\n// Options:\n//\n//   backtracking: .................... false\n//   location.ranges: ................. false\n//   location line+column tracking: ... true\n//\n//\n// Forwarded Parser Analysis flags:\n//\n//   uses yyleng: ..................... false\n//   uses yylineno: ................... false\n//   uses yytext: ..................... false\n//   uses yylloc: ..................... false\n//   uses lexer values: ............... true / true\n//   location tracking: ............... false\n//   location assignment: ............. false\n//\n//\n// Lexer Analysis flags:\n//\n//   uses yyleng: ..................... ???\n//   uses yylineno: ................... ???\n//   uses yytext: ..................... ???\n//   uses yylloc: ..................... ???\n//   uses ParseError API: ............. ???\n//   uses yyerror: .................... ???\n//   uses location tracking & editing:  ???\n//   uses more() API: ................. ???\n//   uses unput() API: ................ ???\n//   uses reject() API: ............... ???\n//   uses less() API: ................. ???\n//   uses display APIs pastInput(), upcomingInput(), showPosition():\n//        ............................. ???\n//   uses describeYYLLOC() API: ....... ???\n//\n// --------- END OF REPORT -----------\n\nEOF: 1,\n    ERROR: 2,\n\n    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator\n\n    // options: {},                             /// <-- injected by the code generator\n\n    // yy: ...,                                 /// <-- injected by setInput()\n\n    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  \n\n    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  \n    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  \n    done: false,                                /// INTERNAL USE ONLY  \n    _backtrack: false,                          /// INTERNAL USE ONLY  \n    _input: '',                                 /// INTERNAL USE ONLY  \n    _more: false,                               /// INTERNAL USE ONLY  \n    _signaled_error_token: false,               /// INTERNAL USE ONLY  \n    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  \n    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  \n    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  \n    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  \n    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  \n    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  \n    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  \n    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  \n    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  \n\n    /**\n     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {\n      msg = '' + msg;\n\n      // heuristic to determine if the error message already contains a (partial) source code dump\n      // as produced by either `showPosition()` or `prettyPrintRange()`:\n      if (show_input_position == undefined) {\n        show_input_position = !(msg.indexOf('\\n') > 0 && msg.indexOf('^') > 0);\n      }\n\n      if (this.yylloc && show_input_position) {\n        if (typeof this.prettyPrintRange === 'function') {\n          var pretty_src = this.prettyPrintRange(this.yylloc);\n\n          if (!/\\n\\s*$/.test(msg)) {\n            msg += '\\n';\n          }\n\n          msg += '\\n  Erroneous area:\\n' + this.prettyPrintRange(this.yylloc);\n        } else if (typeof this.showPosition === 'function') {\n          var pos_str = this.showPosition();\n\n          if (pos_str) {\n            if (msg.length && msg[msg.length - 1] !== '\\n' && pos_str[0] !== '\\n') {\n              msg += '\\n' + pos_str;\n            } else {\n              msg += pos_str;\n            }\n          }\n        }\n      }\n\n      /** @constructor */\n      var pei = {\n        errStr: msg,\n        recoverable: !!recoverable,\n        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  \n        token: null,\n        line: this.yylineno,\n        loc: this.yylloc,\n        yy: this.yy,\n        lexer: this,\n\n        /**\n         * and make sure the error info doesn't stay due to potential\n         * ref cycle via userland code manipulations.\n         * These would otherwise all be memory leak opportunities!\n         * \n         * Note that only array and object references are nuked as those\n         * constitute the set of elements which can produce a cyclic ref.\n         * The rest of the members is kept intact as they are harmless.\n         * \n         * @public\n         * @this {LexErrorInfo}\n         */\n        destroy: function destructLexErrorInfo() {\n          // remove cyclic references added to error info:\n          // info.yy = null;\n          // info.lexer = null;\n          // ...\n          var rec = !!this.recoverable;\n\n          for (var key in this) {\n            if (this.hasOwnProperty(key) && typeof key === 'object') {\n              this[key] = undefined;\n            }\n          }\n\n          this.recoverable = rec;\n        }\n      };\n\n      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n      this.__error_infos.push(pei);\n\n      return pei;\n    },\n\n    /**\n     * handler which is invoked when a lexer error occurs.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    parseError: function lexer_parseError(str, hash, ExceptionClass) {\n      if (!ExceptionClass) {\n        ExceptionClass = this.JisonLexerError;\n      }\n\n      if (this.yy) {\n        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {\n          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n        } else if (typeof this.yy.parseError === 'function') {\n          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n        }\n      }\n\n      throw new ExceptionClass(str, hash);\n    },\n\n    /**\n     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    yyerror: function yyError(str /*, ...args */) {\n      var lineno_msg = '';\n\n      if (this.yylloc) {\n        lineno_msg = ' on line ' + (this.yylineno + 1);\n      }\n\n      var p = this.constructLexErrorInfo(\n        'Lexical error' + lineno_msg + ': ' + str,\n        this.options.lexerErrorsAreRecoverable\n      );\n\n      // Add any extra args to the hash under the name `extra_error_attributes`:\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      if (args.length) {\n        p.extra_error_attributes = args;\n      }\n\n      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n    },\n\n    /**\n     * final cleanup function for when we have completed lexing the input;\n     * make it an API so that external code can use this one once userland\n     * code has decided it's time to destroy any lingering lexer error\n     * hash object instances and the like: this function helps to clean\n     * up these constructs, which *may* carry cyclic references which would\n     * otherwise prevent the instances from being properly and timely\n     * garbage-collected, i.e. this function helps prevent memory leaks!\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {\n      // prevent lingering circular references from causing memory leaks:\n      this.setInput('', {});\n\n      // nuke the error hash info instances created during this run.\n      // Userland code must COPY any data/references\n      // in the error hash instance(s) it is more permanently interested in.\n      if (!do_not_nuke_errorinfos) {\n        for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n          var el = this.__error_infos[i];\n\n          if (el && typeof el.destroy === 'function') {\n            el.destroy();\n          }\n        }\n\n        this.__error_infos.length = 0;\n      }\n\n      return this;\n    },\n\n    /**\n     * clear the lexer token context; intended for internal use only\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    clear: function lexer_clear() {\n      this.yytext = '';\n      this.yyleng = 0;\n      this.match = '';\n\n      // - DO NOT reset `this.matched`\n      this.matches = false;\n\n      this._more = false;\n      this._backtrack = false;\n      var col = (this.yylloc ? this.yylloc.last_column : 0);\n\n      this.yylloc = {\n        first_line: this.yylineno + 1,\n        first_column: col,\n        last_line: this.yylineno + 1,\n        last_column: col,\n        range: [this.offset, this.offset]\n      };\n    },\n\n    /**\n     * resets the lexer, sets new input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    setInput: function lexer_setInput(input, yy) {\n      this.yy = yy || this.yy || {};\n\n      // also check if we've fully initialized the lexer instance,\n      // including expansion work to be done to go from a loaded\n      // lexer to a usable lexer:\n      if (!this.__decompressed) {\n        // step 1: decompress the regex list:\n        var rules = this.rules;\n\n        for (var i = 0, len = rules.length; i < len; i++) {\n          var rule_re = rules[i];\n\n          // compression: is the RE an xref to another RE slot in the rules[] table?\n          if (typeof rule_re === 'number') {\n            rules[i] = rules[rule_re];\n          }\n        }\n\n        // step 2: unfold the conditions[] set to make these ready for use:\n        var conditions = this.conditions;\n\n        for (var k in conditions) {\n          var spec = conditions[k];\n          var rule_ids = spec.rules;\n          var len = rule_ids.length;\n          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! \n          var rule_new_ids = new Array(len + 1);\n\n          for (var i = 0; i < len; i++) {\n            var idx = rule_ids[i];\n            var rule_re = rules[idx];\n            rule_regexes[i + 1] = rule_re;\n            rule_new_ids[i + 1] = idx;\n          }\n\n          spec.rules = rule_new_ids;\n          spec.__rule_regexes = rule_regexes;\n          spec.__rule_count = len;\n        }\n\n        this.__decompressed = true;\n      }\n\n      this._input = input || '';\n      this.clear();\n      this._signaled_error_token = false;\n      this.done = false;\n      this.yylineno = 0;\n      this.matched = '';\n      this.conditionStack = ['INITIAL'];\n      this.__currentRuleSet__ = null;\n\n      this.yylloc = {\n        first_line: 1,\n        first_column: 0,\n        last_line: 1,\n        last_column: 0,\n        range: [0, 0]\n      };\n\n      this.offset = 0;\n      return this;\n    },\n\n    /**\n     * edit the remaining input via user-specified callback.\n     * This can be used to forward-adjust the input-to-parse, \n     * e.g. inserting macro expansions and alike in the\n     * input which has yet to be lexed.\n     * The behaviour of this API contrasts the `unput()` et al\n     * APIs as those act on the *consumed* input, while this\n     * one allows one to manipulate the future, without impacting\n     * the current `yyloc` cursor location or any history. \n     * \n     * Use this API to help implement C-preprocessor-like\n     * `#include` statements, etc.\n     * \n     * The provided callback must be synchronous and is\n     * expected to return the edited input (string).\n     *\n     * The `cpsArg` argument value is passed to the callback\n     * as-is.\n     *\n     * `callback` interface: \n     * `function callback(input, cpsArg)`\n     * \n     * - `input` will carry the remaining-input-to-lex string\n     *   from the lexer.\n     * - `cpsArg` is `cpsArg` passed into this API.\n     * \n     * The `this` reference for the callback will be set to\n     * reference this lexer instance so that userland code\n     * in the callback can easily and quickly access any lexer\n     * API. \n     *\n     * When the callback returns a non-string-type falsey value,\n     * we assume the callback did not edit the input and we\n     * will using the input as-is.\n     *\n     * When the callback returns a non-string-type value, it\n     * is converted to a string for lexing via the `\"\" + retval`\n     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html \n     * -- that way any returned object's `toValue()` and `toString()`\n     * methods will be invoked in a proper/desirable order.)\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {\n      var rv = callback.call(this, this._input, cpsArg);\n\n      if (typeof rv !== 'string') {\n        if (rv) {\n          this._input = '' + rv;\n        } \n        // else: keep `this._input` as is.  \n      } else {\n        this._input = rv;\n      }\n\n      return this;\n    },\n\n    /**\n     * consumes and returns one char from the input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    input: function lexer_input() {\n      if (!this._input) {\n        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)\n        return null;\n      }\n\n      var ch = this._input[0];\n      this.yytext += ch;\n      this.yyleng++;\n      this.offset++;\n      this.match += ch;\n      this.matched += ch;\n\n      // Count the linenumber up when we hit the LF (or a stand-alone CR).\n      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo\n      // and we advance immediately past the LF as well, returning both together as if\n      // it was all a single 'character' only.\n      var slice_len = 1;\n\n      var lines = false;\n\n      if (ch === '\\n') {\n        lines = true;\n      } else if (ch === '\\r') {\n        lines = true;\n        var ch2 = this._input[1];\n\n        if (ch2 === '\\n') {\n          slice_len++;\n          ch += ch2;\n          this.yytext += ch2;\n          this.yyleng++;\n          this.offset++;\n          this.match += ch2;\n          this.matched += ch2;\n          this.yylloc.range[1]++;\n        }\n      }\n\n      if (lines) {\n        this.yylineno++;\n        this.yylloc.last_line++;\n        this.yylloc.last_column = 0;\n      } else {\n        this.yylloc.last_column++;\n      }\n\n      this.yylloc.range[1]++;\n      this._input = this._input.slice(slice_len);\n      return ch;\n    },\n\n    /**\n     * unshifts one char (or an entire string) into the input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    unput: function lexer_unput(ch) {\n      var len = ch.length;\n      var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n      this._input = ch + this._input;\n      this.yytext = this.yytext.substr(0, this.yytext.length - len);\n      this.yyleng = this.yytext.length;\n      this.offset -= len;\n      this.match = this.match.substr(0, this.match.length - len);\n      this.matched = this.matched.substr(0, this.matched.length - len);\n\n      if (lines.length > 1) {\n        this.yylineno -= lines.length - 1;\n        this.yylloc.last_line = this.yylineno + 1;\n\n        // Get last entirely matched line into the `pre_lines[]` array's\n        // last index slot; we don't mind when other previously \n        // matched lines end up in the array too. \n        var pre = this.match;\n\n        var pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n\n        if (pre_lines.length === 1) {\n          pre = this.matched;\n          pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n        }\n\n        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;\n      } else {\n        this.yylloc.last_column -= len;\n      }\n\n      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;\n      this.done = false;\n      return this;\n    },\n\n    /**\n     * cache matched text and append it on next action\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    more: function lexer_more() {\n      this._more = true;\n      return this;\n    },\n\n    /**\n     * signal the lexer that this rule fails to match the input, so the\n     * next matching rule (regex) should be tested instead.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    reject: function lexer_reject() {\n      if (this.options.backtrack_lexer) {\n        this._backtrack = true;\n      } else {\n        // when the `parseError()` call returns, we MUST ensure that the error is registered.\n        // We accomplish this by signaling an 'error' token to be produced for the current\n        // `.lex()` run.\n        var lineno_msg = '';\n\n        if (this.yylloc) {\n          lineno_msg = ' on line ' + (this.yylineno + 1);\n        }\n\n        var p = this.constructLexErrorInfo(\n          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).',\n          false\n        );\n\n        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n      }\n\n      return this;\n    },\n\n    /**\n     * retain first n characters of the match\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    less: function lexer_less(n) {\n      return this.unput(this.match.slice(n));\n    },\n\n    /**\n     * return (part of the) already matched input, i.e. for error\n     * messages.\n     * \n     * Limit the returned string length to `maxSize` (default: 20).\n     * \n     * Limit the returned string to the `maxLines` number of lines of\n     * input (default: 1).\n     * \n     * Negative limit values equal *unlimited*.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    pastInput: function lexer_pastInput(maxSize, maxLines) {\n      var past = this.matched.substring(0, this.matched.length - this.match.length);\n\n      if (maxSize < 0)\n        maxSize = past.length;\n      else if (!maxSize)\n        maxSize = 20;\n\n      if (maxLines < 0)\n        maxLines = past.length;          // can't ever have more input lines than this! \n      else if (!maxLines)\n        maxLines = 1;\n\n      // `substr` anticipation: treat \\r\\n as a single character and take a little\n      // more than necessary so that we can still properly check against maxSize\n      // after we've transformed and limited the newLines in here:\n      past = past.substr(-maxSize * 2 - 2);\n\n      // now that we have a significantly reduced string to process, transform the newlines\n      // and chop them, then limit them:\n      var a = past.replace(/\\r\\n|\\r/g, '\\n').split('\\n');\n\n      a = a.slice(-maxLines);\n      past = a.join('\\n');\n\n      // When, after limiting to maxLines, we still have too much to return,\n      // do add an ellipsis prefix...\n      if (past.length > maxSize) {\n        past = '...' + past.substr(-maxSize);\n      }\n\n      return past;\n    },\n\n    /**\n     * return (part of the) upcoming input, i.e. for error messages.\n     * \n     * Limit the returned string length to `maxSize` (default: 20).\n     * \n     * Limit the returned string to the `maxLines` number of lines of input (default: 1).\n     * \n     * Negative limit values equal *unlimited*.\n     *\n     * > ### NOTE ###\n     * >\n     * > *\"upcoming input\"* is defined as the whole of the both\n     * > the *currently lexed* input, together with any remaining input\n     * > following that. *\"currently lexed\"* input is the input \n     * > already recognized by the lexer but not yet returned with\n     * > the lexer token. This happens when you are invoking this API\n     * > from inside any lexer rule action code block. \n     * >\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {\n      var next = this.match;\n\n      if (maxSize < 0)\n        maxSize = next.length + this._input.length;\n      else if (!maxSize)\n        maxSize = 20;\n\n      if (maxLines < 0)\n        maxLines = maxSize;          // can't ever have more input lines than this! \n      else if (!maxLines)\n        maxLines = 1;\n\n      // `substring` anticipation: treat \\r\\n as a single character and take a little\n      // more than necessary so that we can still properly check against maxSize\n      // after we've transformed and limited the newLines in here:\n      if (next.length < maxSize * 2 + 2) {\n        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 \n      }\n\n      // now that we have a significantly reduced string to process, transform the newlines\n      // and chop them, then limit them:\n      var a = next.replace(/\\r\\n|\\r/g, '\\n').split('\\n');\n\n      a = a.slice(0, maxLines);\n      next = a.join('\\n');\n\n      // When, after limiting to maxLines, we still have too much to return,\n      // do add an ellipsis postfix...\n      if (next.length > maxSize) {\n        next = next.substring(0, maxSize) + '...';\n      }\n\n      return next;\n    },\n\n    /**\n     * return a string which displays the character position where the\n     * lexing error occurred, i.e. for error messages\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {\n      var pre = this.pastInput(maxPrefix).replace(/\\s/g, ' ');\n      var c = new Array(pre.length + 1).join('-');\n      return pre + this.upcomingInput(maxPostfix).replace(/\\s/g, ' ') + '\\n' + c + '^';\n    },\n\n    /**\n     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).\n     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when\n     * it MAY be NULL) and you MUST have a valid location info object anyway:\n     * then we take the given context of the `preceding` and `following` locations, IFF those are available,\n     * and reconstruct the `actual` location info from those.\n     * If this fails, the heuristic is to take the `current` location, IFF available.\n     * If this fails as well, we assume the sought location is at/around the current lexer position\n     * and then produce that one as a response. DO NOTE that these heuristic/derived location info\n     * values MAY be inaccurate!\n     *\n     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just\n     * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {\n      var loc = {\n        first_line: 1,\n        first_column: 0,\n        last_line: 1,\n        last_column: 0,\n        range: [0, 0]\n      };\n\n      if (actual) {\n        loc.first_line = actual.first_line | 0;\n        loc.last_line = actual.last_line | 0;\n        loc.first_column = actual.first_column | 0;\n        loc.last_column = actual.last_column | 0;\n\n        if (actual.range) {\n          loc.range[0] = actual.range[0] | 0;\n          loc.range[1] = actual.range[1] | 0;\n        }\n      }\n\n      if (loc.first_line <= 0 || loc.last_line < loc.first_line) {\n        // plan B: heuristic using preceding and following:\n        if (loc.first_line <= 0 && preceding) {\n          loc.first_line = preceding.last_line | 0;\n          loc.first_column = preceding.last_column | 0;\n\n          if (preceding.range) {\n            loc.range[0] = actual.range[1] | 0;\n          }\n        }\n\n        if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {\n          loc.last_line = following.first_line | 0;\n          loc.last_column = following.first_column | 0;\n\n          if (following.range) {\n            loc.range[1] = actual.range[0] | 0;\n          }\n        }\n\n        // plan C?: see if the 'current' location is useful/sane too:\n        if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {\n          loc.first_line = current.first_line | 0;\n          loc.first_column = current.first_column | 0;\n\n          if (current.range) {\n            loc.range[0] = current.range[0] | 0;\n          }\n        }\n\n        if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {\n          loc.last_line = current.last_line | 0;\n          loc.last_column = current.last_column | 0;\n\n          if (current.range) {\n            loc.range[1] = current.range[1] | 0;\n          }\n        }\n      }\n\n      // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter\n      // or plan D heuristics to produce a 'sensible' last_line value:\n      if (loc.last_line <= 0) {\n        if (loc.first_line <= 0) {\n          loc.first_line = this.yylloc.first_line;\n          loc.last_line = this.yylloc.last_line;\n          loc.first_column = this.yylloc.first_column;\n          loc.last_column = this.yylloc.last_column;\n          loc.range[0] = this.yylloc.range[0];\n          loc.range[1] = this.yylloc.range[1];\n        } else {\n          loc.last_line = this.yylloc.last_line;\n          loc.last_column = this.yylloc.last_column;\n          loc.range[1] = this.yylloc.range[1];\n        }\n      }\n\n      if (loc.first_line <= 0) {\n        loc.first_line = loc.last_line;\n        loc.first_column = 0;  // loc.last_column; \n        loc.range[1] = loc.range[0];\n      }\n\n      if (loc.first_column < 0) {\n        loc.first_column = 0;\n      }\n\n      if (loc.last_column < 0) {\n        loc.last_column = (loc.first_column > 0 ? loc.first_column : 80);\n      }\n\n      return loc;\n    },\n\n    /**\n     * return a string which displays the lines & columns of input which are referenced \n     * by the given location info range, plus a few lines of context.\n     * \n     * This function pretty-prints the indicated section of the input, with line numbers \n     * and everything!\n     * \n     * This function is very useful to provide highly readable error reports, while\n     * the location range may be specified in various flexible ways:\n     * \n     * - `loc` is the location info object which references the area which should be\n     *   displayed and 'marked up': these lines & columns of text are marked up by `^`\n     *   characters below each character in the entire input range.\n     * \n     * - `context_loc` is the *optional* location info object which instructs this\n     *   pretty-printer how much *leading* context should be displayed alongside\n     *   the area referenced by `loc`. This can help provide context for the displayed\n     *   error, etc.\n     * \n     *   When this location info is not provided, a default context of 3 lines is\n     *   used.\n     * \n     * - `context_loc2` is another *optional* location info object, which serves\n     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*\n     *   context lines to display in the pretty-print output.\n     * \n     *   When this location info is not provided, a default context of 1 line only is\n     *   used.\n     * \n     * Special Notes:\n     * \n     * - when the `loc`-indicated range is very large (about 5 lines or more), then\n     *   only the first and last few lines of this block are printed while a\n     *   `...continued...` message will be printed between them.\n     * \n     *   This serves the purpose of not printing a huge amount of text when the `loc`\n     *   range happens to be huge: this way a manageable & readable output results\n     *   for arbitrary large ranges.\n     * \n     * - this function can display lines of input which whave not yet been lexed.\n     *   `prettyPrintRange()` can access the entire input!\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {\n      loc = this.deriveLocationInfo(loc, context_loc, context_loc2);\n      const CONTEXT = 3;\n      const CONTEXT_TAIL = 1;\n      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;\n      var input = this.matched + this._input;\n      var lines = input.split('\\n');\n      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));\n      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));\n      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;\n      var ws_prefix = new Array(lineno_display_width).join(' ');\n      var nonempty_line_indexes = [];\n\n      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {\n        var lno = index + l0;\n        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);\n        var rv = lno_pfx + ': ' + line;\n        var errpfx = new Array(lineno_display_width + 1).join('^');\n        var offset = 2 + 1;\n        var len = 0;\n\n        if (lno === loc.first_line) {\n          offset += loc.first_column;\n\n          len = Math.max(\n            2,\n            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1\n          );\n        } else if (lno === loc.last_line) {\n          len = Math.max(2, loc.last_column + 1);\n        } else if (lno > loc.first_line && lno < loc.last_line) {\n          len = Math.max(2, line.length + 1);\n        }\n\n        if (len) {\n          var lead = new Array(offset).join('.');\n          var mark = new Array(len).join('^');\n          rv += '\\n' + errpfx + lead + mark;\n\n          if (line.trim().length > 0) {\n            nonempty_line_indexes.push(index);\n          }\n        }\n\n        rv = rv.replace(/\\t/g, ' ');\n        return rv;\n      });\n\n      // now make sure we don't print an overly large amount of error area: limit it \n      // to the top and bottom line count:\n      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {\n        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;\n        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;\n        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';\n        intermediate_line += '\\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';\n        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);\n      }\n\n      return rv.join('\\n');\n    },\n\n    /**\n     * helper function, used to produce a human readable description as a string, given\n     * the input `yylloc` location object.\n     * \n     * Set `display_range_too` to TRUE to include the string character index position(s)\n     * in the description if the `yylloc.range` is available.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {\n      var l1 = yylloc.first_line;\n      var l2 = yylloc.last_line;\n      var c1 = yylloc.first_column;\n      var c2 = yylloc.last_column;\n      var dl = l2 - l1;\n      var dc = c2 - c1;\n      var rv;\n\n      if (dl === 0) {\n        rv = 'line ' + l1 + ', ';\n\n        if (dc <= 1) {\n          rv += 'column ' + c1;\n        } else {\n          rv += 'columns ' + c1 + ' .. ' + c2;\n        }\n      } else {\n        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';\n      }\n\n      if (yylloc.range && display_range_too) {\n        var r1 = yylloc.range[0];\n        var r2 = yylloc.range[1] - 1;\n\n        if (r2 <= r1) {\n          rv += ' {String Offset: ' + r1 + '}';\n        } else {\n          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';\n        }\n      }\n\n      return rv;\n    },\n\n    /**\n     * test the lexed token: return FALSE when not a match, otherwise return token.\n     * \n     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`\n     * contains the actually matched text string.\n     * \n     * Also move the input cursor forward and update the match collectors:\n     * \n     * - `yytext`\n     * - `yyleng`\n     * - `match`\n     * - `matches`\n     * - `yylloc`\n     * - `offset`\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    test_match: function lexer_test_match(match, indexed_rule) {\n      var token, lines, backup, match_str, match_str_len;\n\n      if (this.options.backtrack_lexer) {\n        // save context\n        backup = {\n          yylineno: this.yylineno,\n\n          yylloc: {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylloc.last_line,\n            first_column: this.yylloc.first_column,\n            last_column: this.yylloc.last_column,\n            range: this.yylloc.range.slice(0)\n          },\n\n          yytext: this.yytext,\n          match: this.match,\n          matches: this.matches,\n          matched: this.matched,\n          yyleng: this.yyleng,\n          offset: this.offset,\n          _more: this._more,\n          _input: this._input,\n\n          //_signaled_error_token: this._signaled_error_token,\n          yy: this.yy,\n\n          conditionStack: this.conditionStack.slice(0),\n          done: this.done\n        };\n      }\n\n      match_str = match[0];\n      match_str_len = match_str.length;\n\n      // if (match_str.indexOf('\\n') !== -1 || match_str.indexOf('\\r') !== -1) {\n      lines = match_str.split(/(?:\\r\\n?|\\n)/g);\n\n      if (lines.length > 1) {\n        this.yylineno += lines.length - 1;\n        this.yylloc.last_line = this.yylineno + 1;\n        this.yylloc.last_column = lines[lines.length - 1].length;\n      } else {\n        this.yylloc.last_column += match_str_len;\n      }\n\n      // }\n      this.yytext += match_str;\n\n      this.match += match_str;\n      this.matched += match_str;\n      this.matches = match;\n      this.yyleng = this.yytext.length;\n      this.yylloc.range[1] += match_str_len;\n\n      // previous lex rules MAY have invoked the `more()` API rather than producing a token:\n      // those rules will already have moved this `offset` forward matching their match lengths,\n      // hence we must only add our own match length now:\n      this.offset += match_str_len;\n\n      this._more = false;\n      this._backtrack = false;\n      this._input = this._input.slice(match_str_len);\n\n      // calling this method:\n      //\n      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}\n      token = this.performAction.call(\n        this,\n        this.yy,\n        indexed_rule,\n        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */\n      );\n\n      // otherwise, when the action codes are all simple return token statements:\n      //token = this.simpleCaseActionClusters[indexed_rule];\n\n      if (this.done && this._input) {\n        this.done = false;\n      }\n\n      if (token) {\n        return token;\n      } else if (this._backtrack) {\n        // recover context\n        for (var k in backup) {\n          this[k] = backup[k];\n        }\n\n        this.__currentRuleSet__ = null;\n        return false;  // rule action called reject() implying the next rule should be tested instead. \n      } else if (this._signaled_error_token) {\n        // produce one 'error' token as `.parseError()` in `reject()`\n        // did not guarantee a failure signal by throwing an exception!\n        token = this._signaled_error_token;\n\n        this._signaled_error_token = false;\n        return token;\n      }\n\n      return false;\n    },\n\n    /**\n     * return next match in input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    next: function lexer_next() {\n      if (this.done) {\n        this.clear();\n        return this.EOF;\n      }\n\n      if (!this._input) {\n        this.done = true;\n      }\n\n      var token, match, tempMatch, index;\n\n      if (!this._more) {\n        this.clear();\n      }\n\n      var spec = this.__currentRuleSet__;\n\n      if (!spec) {\n        // Update the ruleset cache as we apparently encountered a state change or just started lexing.\n        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will\n        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps\n        // speed up those activities a tiny bit.\n        spec = this.__currentRuleSet__ = this._currentRules();\n\n        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against\n        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19\n        if (!spec || !spec.rules) {\n          var lineno_msg = '';\n\n          if (this.options.trackPosition) {\n            lineno_msg = ' on line ' + (this.yylineno + 1);\n          }\n\n          var p = this.constructLexErrorInfo(\n            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name \"' + this.topState() + '\"; this is a fatal error and should be reported to the application programmer team!',\n            false\n          );\n\n          // produce one 'error' token until this situation has been resolved, most probably by parse termination!\n          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n        }\n      }\n\n      var rule_ids = spec.rules;\n      var regexes = spec.__rule_regexes;\n      var len = spec.__rule_count;\n\n      // Note: the arrays are 1-based, while `len` itself is a valid index,\n      // hence the non-standard less-or-equal check in the next loop condition!\n      for (var i = 1; i <= len; i++) {\n        tempMatch = this._input.match(regexes[i]);\n\n        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n          match = tempMatch;\n          index = i;\n\n          if (this.options.backtrack_lexer) {\n            token = this.test_match(tempMatch, rule_ids[i]);\n\n            if (token !== false) {\n              return token;\n            } else if (this._backtrack) {\n              match = undefined;\n              continue;  // rule action called reject() implying a rule MISmatch. \n            } else {\n              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n              return false;\n            }\n          } else if (!this.options.flex) {\n            break;\n          }\n        }\n      }\n\n      if (match) {\n        token = this.test_match(match, rule_ids[index]);\n\n        if (token !== false) {\n          return token;\n        }\n\n        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n        return false;\n      }\n\n      if (!this._input) {\n        this.done = true;\n        this.clear();\n        return this.EOF;\n      } else {\n        var lineno_msg = '';\n\n        if (this.options.trackPosition) {\n          lineno_msg = ' on line ' + (this.yylineno + 1);\n        }\n\n        var p = this.constructLexErrorInfo(\n          'Lexical error' + lineno_msg + ': Unrecognized text.',\n          this.options.lexerErrorsAreRecoverable\n        );\n\n        var pendingInput = this._input;\n        var activeCondition = this.topState();\n        var conditionStackDepth = this.conditionStack.length;\n        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n\n        if (token === this.ERROR) {\n          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us\n          // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`\n          // has not consumed/modified any pending input or changed state in the error handler:\n          if (!this.matches && // and make sure the input has been modified/consumed ...\n          pendingInput === this._input && // ...or the lexer state has been modified significantly enough\n          // to merit a non-consuming error handling action right now.\n          activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {\n            this.input();\n          }\n        }\n\n        return token;\n      }\n    },\n\n    /**\n     * return next match that has a token\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    lex: function lexer_lex() {\n      var r;\n\n      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:\n      if (typeof this.pre_lex === 'function') {\n        r = this.pre_lex.call(this, 0);\n      }\n\n      if (typeof this.options.pre_lex === 'function') {\n        // (also account for a userdef function which does not return any value: keep the token as is)\n        r = this.options.pre_lex.call(this, r) || r;\n      }\n\n      if (this.yy && typeof this.yy.pre_lex === 'function') {\n        // (also account for a userdef function which does not return any value: keep the token as is)\n        r = this.yy.pre_lex.call(this, r) || r;\n      }\n\n      while (!r) {\n        r = this.next();\n      }\n\n      if (this.yy && typeof this.yy.post_lex === 'function') {\n        // (also account for a userdef function which does not return any value: keep the token as is)\n        r = this.yy.post_lex.call(this, r) || r;\n      }\n\n      if (typeof this.options.post_lex === 'function') {\n        // (also account for a userdef function which does not return any value: keep the token as is)\n        r = this.options.post_lex.call(this, r) || r;\n      }\n\n      if (typeof this.post_lex === 'function') {\n        // (also account for a userdef function which does not return any value: keep the token as is)\n        r = this.post_lex.call(this, r) || r;\n      }\n\n      return r;\n    },\n\n    /**\n     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the \n     * `pre_lex()` nor any of the `post_lex()` callbacks.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    fastLex: function lexer_fastLex() {\n      var r;\n\n      while (!r) {\n        r = this.next();\n      }\n\n      return r;\n    },\n\n    /**\n     * return info about the lexer state that can help a parser or other lexer API user to use the\n     * most efficient means available. This API is provided to aid run-time performance for larger\n     * systems which employ this lexer.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    canIUse: function lexer_canIUse() {\n      var rv = {\n        fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'\n      };\n\n      return rv;\n    },\n\n    /**\n     * backwards compatible alias for `pushState()`;\n     * the latter is symmetrical with `popState()` and we advise to use\n     * those APIs in any modern lexer code, rather than `begin()`.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    begin: function lexer_begin(condition) {\n      return this.pushState(condition);\n    },\n\n    /**\n     * activates a new lexer condition state (pushes the new lexer\n     * condition state onto the condition stack)\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    pushState: function lexer_pushState(condition) {\n      this.conditionStack.push(condition);\n      this.__currentRuleSet__ = null;\n      return this;\n    },\n\n    /**\n     * pop the previously active lexer condition state off the condition\n     * stack\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    popState: function lexer_popState() {\n      var n = this.conditionStack.length - 1;\n\n      if (n > 0) {\n        this.__currentRuleSet__ = null;\n        return this.conditionStack.pop();\n      } else {\n        return this.conditionStack[0];\n      }\n    },\n\n    /**\n     * return the currently active lexer condition state; when an index\n     * argument is provided it produces the N-th previous condition state,\n     * if available\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    topState: function lexer_topState(n) {\n      n = this.conditionStack.length - 1 - Math.abs(n || 0);\n\n      if (n >= 0) {\n        return this.conditionStack[n];\n      } else {\n        return 'INITIAL';\n      }\n    },\n\n    /**\n     * (internal) determine the lexer rule set which is active for the\n     * currently active lexer condition state\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    _currentRules: function lexer__currentRules() {\n      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];\n      } else {\n        return this.conditions['INITIAL'];\n      }\n    },\n\n    /**\n     * return the number of states currently on the stack\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    stateStackSize: function lexer_stateStackSize() {\n      return this.conditionStack.length;\n    },\n\n    options: {\n      trackPosition: true\n    },\n\n    JisonLexerError: JisonLexerError,\n\n    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {\n      var yy_ = this;\n      var YYSTATE = YY_START;\n\n      switch (yyrulenumber) {\n      case 1:\n        /*! Conditions:: INITIAL */\n        /*! Rule::       \\s+ */\n        /* skip whitespace */\n        break;\n\n      default:\n        return this.simpleCaseActionClusters[yyrulenumber];\n      }\n    },\n\n    simpleCaseActionClusters: {\n      /*! Conditions:: INITIAL */\n      /*! Rule::       (--[0-9a-z-A-Z-]*) */\n      0: 13,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\* */\n      2: 5,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\/ */\n      3: 6,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\+ */\n      4: 3,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       - */\n      5: 4,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)px\\b */\n      6: 15,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)cm\\b */\n      7: 15,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)mm\\b */\n      8: 15,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)in\\b */\n      9: 15,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pt\\b */\n      10: 15,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pc\\b */\n      11: 15,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)deg\\b */\n      12: 16,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)grad\\b */\n      13: 16,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rad\\b */\n      14: 16,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)turn\\b */\n      15: 16,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)s\\b */\n      16: 17,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ms\\b */\n      17: 17,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)Hz\\b */\n      18: 18,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)kHz\\b */\n      19: 18,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpi\\b */\n      20: 19,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpcm\\b */\n      21: 19,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dppx\\b */\n      22: 19,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)em\\b */\n      23: 20,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ex\\b */\n      24: 21,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ch\\b */\n      25: 22,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rem\\b */\n      26: 23,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vw\\b */\n      27: 25,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vh\\b */\n      28: 24,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmin\\b */\n      29: 26,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmax\\b */\n      30: 27,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)% */\n      31: 28,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)\\b */\n      32: 11,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       (calc) */\n      33: 9,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       (var) */\n      34: 12,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       ([a-z]+) */\n      35: 10,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\( */\n      36: 7,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       \\) */\n      37: 8,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       , */\n      38: 14,\n\n      /*! Conditions:: INITIAL */\n      /*! Rule::       $ */\n      39: 1\n    },\n\n    rules: [\n      /*  0: */  /^(?:(--[\\d\\-A-Za-z]*))/,\n      /*  1: */  /^(?:\\s+)/,\n      /*  2: */  /^(?:\\*)/,\n      /*  3: */  /^(?:\\/)/,\n      /*  4: */  /^(?:\\+)/,\n      /*  5: */  /^(?:-)/,\n      /*  6: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)px\\b)/,\n      /*  7: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)cm\\b)/,\n      /*  8: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)mm\\b)/,\n      /*  9: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)in\\b)/,\n      /* 10: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pt\\b)/,\n      /* 11: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pc\\b)/,\n      /* 12: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)deg\\b)/,\n      /* 13: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)grad\\b)/,\n      /* 14: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rad\\b)/,\n      /* 15: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)turn\\b)/,\n      /* 16: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)s\\b)/,\n      /* 17: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ms\\b)/,\n      /* 18: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)Hz\\b)/,\n      /* 19: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)kHz\\b)/,\n      /* 20: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpi\\b)/,\n      /* 21: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpcm\\b)/,\n      /* 22: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dppx\\b)/,\n      /* 23: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)em\\b)/,\n      /* 24: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ex\\b)/,\n      /* 25: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ch\\b)/,\n      /* 26: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rem\\b)/,\n      /* 27: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vw\\b)/,\n      /* 28: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vh\\b)/,\n      /* 29: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmin\\b)/,\n      /* 30: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmax\\b)/,\n      /* 31: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)%)/,\n      /* 32: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)\\b)/,\n      /* 33: */  /^(?:(calc))/,\n      /* 34: */  /^(?:(var))/,\n      /* 35: */  /^(?:([a-z]+))/,\n      /* 36: */  /^(?:\\()/,\n      /* 37: */  /^(?:\\))/,\n      /* 38: */  /^(?:,)/,\n      /* 39: */  /^(?:$)/\n    ],\n\n    conditions: {\n      'INITIAL': {\n        rules: [\n          0,\n          1,\n          2,\n          3,\n          4,\n          5,\n          6,\n          7,\n          8,\n          9,\n          10,\n          11,\n          12,\n          13,\n          14,\n          15,\n          16,\n          17,\n          18,\n          19,\n          20,\n          21,\n          22,\n          23,\n          24,\n          25,\n          26,\n          27,\n          28,\n          29,\n          30,\n          31,\n          32,\n          33,\n          34,\n          35,\n          36,\n          37,\n          38,\n          39\n        ],\n\n        inclusive: true\n      }\n    }\n  };\n\n  return lexer;\n}();\nparser.lexer = lexer;\n\n\n\nfunction Parser() {\n  this.yy = {};\n}\nParser.prototype = parser;\nparser.Parser = Parser;\n\nreturn new Parser();\n})();\n\n        \n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  exports.parser = parser;\n  exports.Parser = parser.Parser;\n  exports.parse = function () {\n    return parser.parse.apply(parser, arguments);\n  };\n  \n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3682, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3686, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/reduce-css-calc/dist/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _postcssValueParser = require('postcss-value-parser');\n\nvar _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);\n\nvar _parser = require('./parser');\n\nvar _reducer = require('./lib/reducer');\n\nvar _reducer2 = _interopRequireDefault(_reducer);\n\nvar _stringifier = require('./lib/stringifier');\n\nvar _stringifier2 = _interopRequireDefault(_stringifier);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// eslint-disable-line\nvar MATCH_CALC = /((?:\\-[a-z]+\\-)?calc)/;\n\nexports.default = function (value) {\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n  return (0, _postcssValueParser2.default)(value).walk(function (node) {\n    // skip anything which isn't a calc() function\n    if (node.type !== 'function' || !MATCH_CALC.test(node.value)) return;\n\n    // stringify calc expression and produce an AST\n    var contents = _postcssValueParser2.default.stringify(node.nodes);\n\n    // skip constant() and env()\n    if (contents.indexOf('constant') >= 0 || contents.indexOf('env') >= 0) return;\n\n    var ast = _parser.parser.parse(contents);\n\n    // reduce AST to its simplest form, that is, either to a single value\n    // or a simplified calc expression\n    var reducedAst = (0, _reducer2.default)(ast, precision);\n\n    // stringify AST and write it back\n    node.type = 'word';\n    node.value = (0, _stringifier2.default)(node.value, reducedAst, precision);\n  }, true).toString();\n};\n\nmodule.exports = exports['default'];"],"names":[],"mappings":"AAAA;AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AAEA,IAAI,sBAAsB;AAE1B,IAAI,uBAAuB,uBAAuB;AAElD,IAAI,UAAU;AAEd,IAAI,WAAW;AAEf,IAAI,YAAY,uBAAuB;AAEvC,IAAI,eAAe;AAEnB,IAAI,gBAAgB,uBAAuB;AAE3C,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F,sBAAsB;AACtB,IAAI,aAAa;AAEjB,QAAQ,OAAO,GAAG,SAAU,KAAK;IAC/B,IAAI,YAAY,UAAU,MAAM,GAAG,KAAK,SAAS,CAAC,EAAE,KAAK,YAAY,SAAS,CAAC,EAAE,GAAG;IAEpF,OAAO,AAAC,CAAA,GAAG,qBAAqB,OAAO,AAAD,EAAG,OAAO,IAAI,CAAC,SAAU,IAAI;QACjE,8CAA8C;QAC9C,IAAI,KAAK,IAAI,KAAK,cAAc,CAAC,WAAW,IAAI,CAAC,KAAK,KAAK,GAAG;QAE9D,+CAA+C;QAC/C,IAAI,WAAW,qBAAqB,OAAO,CAAC,SAAS,CAAC,KAAK,KAAK;QAEhE,4BAA4B;QAC5B,IAAI,SAAS,OAAO,CAAC,eAAe,KAAK,SAAS,OAAO,CAAC,UAAU,GAAG;QAEvE,IAAI,MAAM,QAAQ,MAAM,CAAC,KAAK,CAAC;QAE/B,qEAAqE;QACrE,kCAAkC;QAClC,IAAI,aAAa,AAAC,CAAA,GAAG,UAAU,OAAO,AAAD,EAAG,KAAK;QAE7C,kCAAkC;QAClC,KAAK,IAAI,GAAG;QACZ,KAAK,KAAK,GAAG,AAAC,CAAA,GAAG,cAAc,OAAO,AAAD,EAAG,KAAK,KAAK,EAAE,YAAY;IAClE,GAAG,MAAM,QAAQ;AACnB;AAEA,OAAO,OAAO,GAAG,OAAO,CAAC,UAAU"}},
    {"offset": {"line": 3723, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}