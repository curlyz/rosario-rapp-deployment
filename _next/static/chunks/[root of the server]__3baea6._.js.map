{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/pid.ts"],"sourcesContent":["\"use client\";\n\nimport { produce } from \"immer\";\nimport { queryDevice } from \"./connection\";\nimport { initialState } from \"./provider\";\nimport { isInitialized } from \"./connection\";\n\n// + finalized\nexport interface IPidState {\n  isActive: boolean;\n  targetTemperature: number;\n  proportional: number;\n  integral: number;\n  derivative: number;\n  activeRange: number;\n}\n\nexport const pidInitialState: IPidState[] = new Array(3).fill({\n  isActive: false,\n  proportional: 0,\n  integral: 0,\n  derivative: 0,\n  targetTemperature: 0,\n  activeRange: 0,\n});\n\nexport interface IPidDisplay {\n  currentTemperature: number;\n  currentPower: number;\n  powerSamples: number[];\n  temperatureSamples: number[];\n}\nexport const pidInitialDisplay: IPidDisplay[] = new Array(3).fill({\n  currentTemperature: 0,\n  currentPower: 0,\n  temperatureSamples: Array(100).fill(0),\n  powerSamples: Array(100).fill(0),\n});\n\nexport class PidSettingParameter {\n  proportional: number;\n  integral: number;\n  derivative: number;\n  targetTemperature: number;\n  activeRange: number;\n  isActive: boolean;\n\n  constructor({\n    proportional,\n    integral,\n    derivative,\n    targetTemperature,\n    activeRange,\n    isActive,\n  }: {\n    proportional: number;\n    integral: number;\n    derivative: number;\n    targetTemperature: number;\n    activeRange: number;\n    isActive: boolean;\n  }) {\n    this.proportional = proportional;\n    this.integral = integral;\n    this.derivative = derivative;\n    this.targetTemperature = targetTemperature;\n    this.activeRange = activeRange;\n    this.isActive = isActive;\n  }\n  isEqual(other: PidSettingParameter): boolean {\n    return (\n      this.proportional === other.proportional &&\n      this.integral === other.integral &&\n      this.derivative === other.derivative &&\n      this.targetTemperature === other.targetTemperature &&\n      this.activeRange === other.activeRange &&\n      this.isActive === other.isActive\n    );\n  }\n}\n\nexport class PidStatusParameter {\n  currentTemperature: number;\n  currentPower: number;\n  temperatureSamples: number[];\n  powerSamples: number[];\n  constructor({\n    currentTemperature,\n    currentPower,\n    temperatureSamples,\n    powerSamples,\n  }: {\n    currentTemperature: number;\n    currentPower: number;\n    temperatureSamples: number[];\n    powerSamples: number[];\n  }) {\n    this.currentTemperature = currentTemperature;\n    this.currentPower = currentPower;\n    this.temperatureSamples = temperatureSamples;\n    this.powerSamples = powerSamples;\n  }\n}\n\nconst syncedPidState = new Map<number, PidSettingParameter>();\nexport async function setPidConfiguration({\n  channel,\n  pid,\n}: {\n  channel: number;\n  pid: PidSettingParameter;\n}) {\n  // only send if different\n\n  // dont run this if device hasn't get the initializeSync process done\n  if (!isInitialized) {\n    return false;\n  }\n  await queryDevice({\n    command: \"pid.set\",\n    channel: channel,\n    proportional: pid.proportional,\n    integral: pid.integral,\n    derivative: pid.derivative,\n    targetTemperature: pid.targetTemperature,\n    activeRange: pid.activeRange,\n    isActive: pid.isActive,\n  });\n  return true;\n}\n\nexport async function syncPidConfigurationFromDevice({\n  channel,\n}: {\n  channel: number;\n}): Promise<PidSettingParameter> {\n  const request = await queryDevice({\n    command: \"pid.get\",\n    channel,\n  });\n\n  const pid = new PidSettingParameter({\n    proportional: request[\"response\"][\"proportional\"] as number,\n    integral: request[\"response\"][\"integral\"] as number,\n    derivative: request[\"response\"][\"derivative\"] as number,\n    targetTemperature: request[\"response\"][\"targetTemperature\"] as number,\n    activeRange: request[\"response\"][\"activeRange\"] as number,\n    isActive: request[\"response\"][\"isActive\"] as boolean,\n    // history: {\n    //     power: request['response']['history']['power'] as number[],\n    //     temperature: request['response']['history']['temperature'] as number[]\n    // }\n  });\n\n  const ctx = (window as any).ctx as typeof initialState;\n  ctx.setPidState(\n    produce(ctx.pidState, (draft) => {\n      draft[channel].proportional = pid.proportional;\n      draft[channel].integral = pid.integral;\n      draft[channel].derivative = pid.derivative;\n      draft[channel].targetTemperature = pid.targetTemperature;\n      draft[channel].activeRange = pid.activeRange;\n      draft[channel].isActive = pid.isActive;\n    }),\n  );\n\n  return pid;\n}\n\nexport async function syncPidStatus({\n  channel,\n}: {\n  channel: number;\n}): Promise<PidStatusParameter> {\n  const request = await queryDevice({\n    command: \"pid.status\",\n    channel: channel,\n  });\n\n  const status = new PidStatusParameter({\n    currentTemperature: request[\"response\"][\"currentTemperature\"] as number,\n    currentPower: request[\"response\"][\"currentPower\"] as number,\n    temperatureSamples: request[\"response\"][\"temperatureSamples\"] as number[],\n    powerSamples: request[\"response\"][\"powerSamples\"] as number[],\n  });\n  console.log(\"sync pid status\", {status, channel, request  });\n\n  const ctx = (window as any).ctx as typeof initialState;\n  \n\n  ctx.setPidDisplay(produce(ctx.pidDisplay, draft => {\n      draft[channel].currentTemperature = status.currentTemperature;\n      draft[channel].currentPower = status.currentPower;\n      draft[channel].temperatureSamples = status.temperatureSamples;\n      draft[channel].powerSamples = status.powerSamples;\n  }))\n\n  return status;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;;AAiBO,MAAM,kBAA+B,IAAI,MAAM,GAAG,IAAI,CAAC;IAC5D,UAAU;IACV,cAAc;IACd,UAAU;IACV,YAAY;IACZ,mBAAmB;IACnB,aAAa;AACf;AAQO,MAAM,oBAAmC,IAAI,MAAM,GAAG,IAAI,CAAC;IAChE,oBAAoB;IACpB,cAAc;IACd,oBAAoB,MAAM,KAAK,IAAI,CAAC;IACpC,cAAc,MAAM,KAAK,IAAI,CAAC;AAChC;AAEO,MAAM;IACX,aAAqB;IACrB,SAAiB;IACjB,WAAmB;IACnB,kBAA0B;IAC1B,YAAoB;IACpB,SAAkB;IAElB,YAAY,EACV,YAAY,EACZ,QAAQ,EACR,UAAU,EACV,iBAAiB,EACjB,WAAW,EACX,QAAQ,EAQT,CAAE;QACD,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,QAAQ,GAAG;IAClB;IACA,QAAQ,KAA0B,EAAW;QAC3C,OACE,IAAI,CAAC,YAAY,KAAK,MAAM,YAAY,IACxC,IAAI,CAAC,QAAQ,KAAK,MAAM,QAAQ,IAChC,IAAI,CAAC,UAAU,KAAK,MAAM,UAAU,IACpC,IAAI,CAAC,iBAAiB,KAAK,MAAM,iBAAiB,IAClD,IAAI,CAAC,WAAW,KAAK,MAAM,WAAW,IACtC,IAAI,CAAC,QAAQ,KAAK,MAAM,QAAQ;IAEpC;AACF;AAEO,MAAM;IACX,mBAA2B;IAC3B,aAAqB;IACrB,mBAA6B;IAC7B,aAAuB;IACvB,YAAY,EACV,kBAAkB,EAClB,YAAY,EACZ,kBAAkB,EAClB,YAAY,EAMb,CAAE;QACD,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAI,CAAC,YAAY,GAAG;IACtB;AACF;AAEA,MAAM,iBAAiB,IAAI;AACpB,eAAe,oBAAoB,EACxC,OAAO,EACP,GAAG,EAIJ;IACC,yBAAyB;IAEzB,qEAAqE;IACrE,IAAI,4IAAgB;QAClB,OAAO;IACT;IACA,MAAM,wIAAY;QAChB,SAAS;QACT,SAAS;QACT,cAAc,IAAI,YAAY;QAC9B,UAAU,IAAI,QAAQ;QACtB,YAAY,IAAI,UAAU;QAC1B,mBAAmB,IAAI,iBAAiB;QACxC,aAAa,IAAI,WAAW;QAC5B,UAAU,IAAI,QAAQ;IACxB;IACA,OAAO;AACT;AAEO,eAAe,+BAA+B,EACnD,OAAO,EAGR;IACC,MAAM,UAAU,MAAM,wIAAY;QAChC,SAAS;QACT;IACF;IAEA,MAAM,MAAM,IAAI,oBAAoB;QAClC,cAAc,OAAO,CAAC,WAAW,CAAC,eAAe;QACjD,UAAU,OAAO,CAAC,WAAW,CAAC,WAAW;QACzC,YAAY,OAAO,CAAC,WAAW,CAAC,aAAa;QAC7C,mBAAmB,OAAO,CAAC,WAAW,CAAC,oBAAoB;QAC3D,aAAa,OAAO,CAAC,WAAW,CAAC,cAAc;QAC/C,UAAU,OAAO,CAAC,WAAW,CAAC,WAAW;IAK3C;IAEA,MAAM,MAAM,AAAC,OAAe,GAAG;IAC/B,IAAI,WAAW,CACb,+IAAQ,IAAI,QAAQ,EAAE,CAAC;QACrB,KAAK,CAAC,QAAQ,CAAC,YAAY,GAAG,IAAI,YAAY;QAC9C,KAAK,CAAC,QAAQ,CAAC,QAAQ,GAAG,IAAI,QAAQ;QACtC,KAAK,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,UAAU;QAC1C,KAAK,CAAC,QAAQ,CAAC,iBAAiB,GAAG,IAAI,iBAAiB;QACxD,KAAK,CAAC,QAAQ,CAAC,WAAW,GAAG,IAAI,WAAW;QAC5C,KAAK,CAAC,QAAQ,CAAC,QAAQ,GAAG,IAAI,QAAQ;IACxC;IAGF,OAAO;AACT;AAEO,eAAe,cAAc,EAClC,OAAO,EAGR;IACC,MAAM,UAAU,MAAM,wIAAY;QAChC,SAAS;QACT,SAAS;IACX;IAEA,MAAM,SAAS,IAAI,mBAAmB;QACpC,oBAAoB,OAAO,CAAC,WAAW,CAAC,qBAAqB;QAC7D,cAAc,OAAO,CAAC,WAAW,CAAC,eAAe;QACjD,oBAAoB,OAAO,CAAC,WAAW,CAAC,qBAAqB;QAC7D,cAAc,OAAO,CAAC,WAAW,CAAC,eAAe;IACnD;IACA,QAAQ,GAAG,CAAC,mBAAmB;QAAC;QAAQ;QAAS;IAAS;IAE1D,MAAM,MAAM,AAAC,OAAe,GAAG;IAG/B,IAAI,aAAa,CAAC,+IAAQ,IAAI,UAAU,EAAE,CAAA;QACtC,KAAK,CAAC,QAAQ,CAAC,kBAAkB,GAAG,OAAO,kBAAkB;QAC7D,KAAK,CAAC,QAAQ,CAAC,YAAY,GAAG,OAAO,YAAY;QACjD,KAAK,CAAC,QAAQ,CAAC,kBAAkB,GAAG,OAAO,kBAAkB;QAC7D,KAAK,CAAC,QAAQ,CAAC,YAAY,GAAG,OAAO,YAAY;IACrD;IAEA,OAAO;AACT"}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/event.ts"],"sourcesContent":["import { mailbox } from \"./connection\";\nimport { handleFeedback, initialState } from \"./provider\";\nimport { produce } from 'immer'\n// @refresh reset\n\n/**\n * Although most of the data transfer are JSON based dictionary\n * Some, for optimization, sent as number[], which is very compact, around 20 bytes\n *\n */\n\nexport class FlowmeterUpdateEvent {\n  flowmeter: number[];\n  flowrate: number[];\n  constructor(data: number[]) {\n    this.flowmeter = [data[0], data[2], data[4]];\n    this.flowrate = [data[1], data[3], data[5]];\n  }\n}\n\nexport class ButtonClickEvent {\n  groupId: number;\n  controlButton: boolean;\n  coffeeButtons: boolean[]; // 4 buttons\n  doseButton: boolean;\n\n  // if groupId == 0, use these\n  _waterButton: boolean;\n  _doseButton: boolean;\n  _warmerButton: boolean;\n\n  constructor(data: number[]) {\n    this.groupId = data[0] as number;\n    this.controlButton = !data[1];\n    this.coffeeButtons = [!data[2], !data[3], !data[4], !data[5]];\n    this.doseButton = !data[6];\n    // this._waterButton = !data[7];\n    // this._doseButton = !data[8];\n    // this._warmerButton = !data[9];\n  }\n}\n\nexport class ButtonBrightnessEvent {\n  groupId: number;\n  controlButton: number;\n  coffeeButtons: number[]; // 4 buttons\n  doseButton: number;\n  // if groupId == 0, use these\n  _waterButton: number;\n  _doseButton: number;\n  _warmerButton: number;\n\n  constructor(data: number[]) {\n    this.groupId = data[0] as number;\n    this.controlButton = data[1];\n    this.coffeeButtons = [data[2], data[3], data[4], data[5]];\n    this.doseButton = data[6];\n    // this._waterButton = data[7];\n    // this._doseButton = data[8];\n    // this._warmerButton = data[9];\n  }\n}\n\nexport class RelayUpdateEvent {\n  pump: number; // 0\n  group: boolean[]; // 1, 2, 3\n  refill: boolean; // 4\n  warmer: boolean; // 5\n  dose: boolean; // 6\n  boiler: boolean; // 7\n\n  constructor(data: number[]) {\n    this.pump = data[0];\n    this.group = [!!data[1], !!data[2], !!data[3]];\n    this.refill = !!data[4];\n    this.warmer = !!data[5];\n    this.dose = !!data[6];\n    this.boiler = !!data[7];\n  }\n}\n\nexport class PidUpdateEvent {\n  kp: number[];\n  ki: number[];\n  kd: number[];\n  taret: number[];\n  range: number[];\n  temperature: number[];\n  power: number[];\n\n  constructor(data: number[]) {}\n}\n\nexport class TerminalUpdateEvent {\n  message: string;\n  constructor(data: string) {\n    this.message = data;\n  }\n}\n\nexport type UpdateEvent =\n  | ButtonClickEvent\n  | ButtonBrightnessEvent\n  | RelayUpdateEvent\n  | PidUpdateEvent\n  | TerminalUpdateEvent\n  | FlowmeterUpdateEvent;\n\nexport class UnknownUpdateEvent {\n  data: number[];\n  constructor(data: number[]) {\n    this.data = data;\n  }\n}\n\ninterface ResponseQueryEvent {}\nenum EventType {\n  ButtonClick = 0xb0,\n  RelayUpdate = 0xb1,\n  FlowmeterUpdate = 0xb2,\n  PidUpdate = 0xb3,\n  ButtonBrightness = 0xb5,\n  TerminalUpdate = 0xb6,\n  ResponseQuery = 0xb7,\n}\n\nimport { Header } from \"./connection\";\nexport function interpretMessage(\n  header: Header,\n  data: number[] | { [key: string]: any },\n) {\n  console.debug(\"Interpreet\", data);\n\n  const ctx = (window as any).ctx as typeof initialState;\n\n  if (Array.isArray(data)) {\n    console.debug(\"Data is an array\");\n\n    const uuid = data[0];\n    const event = data[1];\n    const payload = data.slice(2);\n\n    if (event == EventType.ButtonClick) {\n      // updateState(new ButtonClickEvent(payload))\n    } else if (event == EventType.ButtonBrightness) {\n      // updateState(new ButtonBrightnessEvent(payload))\n    } else if (event == EventType.RelayUpdate) {\n      // updateState(new RelayUpdateEvent(payload))\n    } else if (event == EventType.PidUpdate) {\n      // updateState(new PidUpdateEvent(payload))\n    } else if (event == EventType.TerminalUpdate) {\n      // updateState(new TerminalUpdateEvent(payload as any))\n    } else if (event == EventType.FlowmeterUpdate) {\n      // updateState(new FlowmeterUpdateEvent(payload))\n      console.log('fm/ update', event, payload)\n      // this is an array of 8\n      // 0 is flowcount, 1 is flowrate and so on\n      // don't update state too fast\n\n\n      // ctx.setFlowCount(produce(ctx.flowCount, draft => {\n      //   draft = [\n      //     payload[0],\n      //     payload[2],\n      //     payload[4]\n      //   ]\n      //   return draft\n      // }))\n      // ctx.setFlowRate(\n      //   produce(ctx.flowRate, draft => {\n      //     draft = [\n      //       payload[1],\n      //       payload[3],\n      //       payload[5]\n      //     ]\n      //     return draft\n      //   }))\n\n      ctx.setFlowmeterDisplay(produce(ctx.flowmeterDisplay, draft => {\n        draft = [\n          {\n            flowCount: Math.round((payload[0] * ctx.calibration.flowmeter[0]) * 10) / 10,\n            flowRate: Math.round((payload[1] * ctx.calibration.flowmeter[0]) * 10) / 10\n          },\n          {\n            flowCount: Math.round((payload[2] * ctx.calibration.flowmeter[1]) * 10) / 10,\n            flowRate: Math.round((payload[3] * ctx.calibration.flowmeter[1]) * 10) / 10\n          },\n          {\n            flowCount: Math.round((payload[4] * ctx.calibration.flowmeter[2]) * 10) / 10,\n            flowRate: Math.round((payload[5] * ctx.calibration.flowmeter[2]) * 10) / 10\n          }\n        ]\n        return draft\n      }))\n\n    } else {\n      return new UnknownUpdateEvent(payload);\n    }\n  } else if (typeof data === \"object\") {\n    console.debug(\"Data is an object/dictionary\");\n    const id = data[\"id\"] as number;\n\n    if (mailbox.hasOwnProperty(id)) {\n      mailbox[id] = data;\n    }\n\n    if (data.command && data.command.startsWith(\"rp.\")) {\n      handleFeedback(data);\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 344, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/connection.ts"],"sourcesContent":["\"use client\";\n\nimport { decode, encode } from \"@msgpack/msgpack\";\nimport { interpretMessage } from \"./event\";\nimport { getGrinderConfiguration } from \"./grinder\";\nimport { syncPidConfigurationFromDevice } from \"./pid\";\nimport { initialState } from \"@/gateway/provider\";\nimport { produce } from \"immer\";\nimport { syncCalibrationFromDevice } from \"./calibration\";\n\nasync function sleep(ms: number) {\n  await new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n\nexport var isInitialized = false\n\nasync function initializeSync() {\n  console.log('initilizeSync')\n  // while the device is still connected, do the sync\n  //% load the pid state\n  const ctx = (window as any).ctx as typeof initialState\n\n  for (var channel = 0; channel < 3; channel++) {\n    await syncPidConfigurationFromDevice({ channel })\n  }\n\n  await syncCalibrationFromDevice()\n  isInitialized = true\n\n}\n\nexport function handleConnectButton() {\n  console.debug(\"State\", device);\n  if (device === null) {\n    requestDevice();\n  } else {\n    disconnectDevice();\n  }\n}\n\nexport interface Header {\n  isFinished: boolean;\n  isFirst: boolean;\n  isCompressed: boolean;\n  requireAck: boolean;\n  channel: number;\n  payloadLength: number;\n  frameType: number;\n}\n\nexport let device: BluetoothDevice | null = null;\nexport let charact: BluetoothRemoteGATTCharacteristic;\nexport let mtu: number = 20;\nexport let incomeBuffer: Uint8Array = new Uint8Array();\nexport let reconnectTimeout: ReturnType<typeof setTimeout>;\n\nexport async function connectDevice(device: BluetoothDevice) {\n  console.debug(\"gateway/ attempt to connect to device\");\n  if (device?.gatt == undefined) {\n    console.error(\"ble/ gatt doesn't exist\", device);\n    return;\n  }\n\n  await device.gatt.connect();\n  const rosarioService = await device.gatt.getPrimaryService(\n    \"0000ffe0-0000-1000-8000-00805f9b34fb\",\n  );\n  console.debug(\"ble/ rosarioService connected\", rosarioService);\n  charact = await rosarioService.getCharacteristic(\n    \"0000ee00-0000-1000-8000-00805f9b34fb\",\n  );\n  charact.addEventListener(\"characteristicvaluechanged\", (event: Event) => {\n    const recv = (event.target as BluetoothRemoteGATTCharacteristic).value;\n    if (recv == null) return;\n    decodeMessage(new Uint8Array(recv.buffer));\n  });\n  charact.startNotifications();\n  console.debug(\"ble/ general characteristic connected\", charact);\n\n  // read the mtu characteristic\n  const mtuCharact = await rosarioService.getCharacteristic(\n    \"0000ee01-0000-1000-8000-00805f9b34fb\",\n  );\n\n  // Convert DataView to int, LSB\n  mtu = (await mtuCharact.readValue()).getUint16(0, true);\n  if (mtu >= 500) {\n    mtu = 500;\n  }\n\n  const firmwareCharact = await rosarioService.getCharacteristic(\n    \"0000ee02-0000-1000-8000-00805f9b34fb\",\n  );\n\n  // Convert DataView to int, LSB\n  let firmwareVersion = 0;\n  firmwareVersion = (await firmwareCharact.readValue()).getUint16(0, true);\n\n  console.debug(\n    \"Connect device success\",\n    device.name,\n    \"fw:\",\n    firmwareVersion,\n    \"mtu:\",\n    mtu,\n  );\n\n  (window as any).ctx.setConnectButtonStyle(\"solid\");\n  (window as any).ctx.setConnectButtonText(\n    device.name?.replace(\"AnataLAB\", \"\") || \"Device\",\n  );\n  (window as any).ctx.setConnected(true);\n\n  setTimeout(async () => {\n    await initializeSync();\n  }, 2000);\n}\n\nexport function decodeMessage(data: Uint8Array) {\n  console.debug(\"/\");\n  // Get the first 4 bytes of data\n  const headerRaw = data.slice(0, 4);\n  const header = {\n    isFinished: headerRaw[0] & 0b00000001 ? true : false,\n    isFirst: headerRaw[0] & 0b00000010 ? true : false,\n    isCompressed: headerRaw[0] & 0b00000100 ? true : false,\n    requireAck: headerRaw[0] & 0b00001000 ? true : false,\n    channel: headerRaw[1],\n    payloadLength: headerRaw[3] + (headerRaw[2] << 8),\n    frameType: headerRaw[0] & 0b11110000, // this is reversed\n  };\n  const payload = data.slice(4);\n  console.debug(\"decodeMessage\", header, header.frameType);\n\n  if (header.frameType == 48) {\n    console.debug(\"ack signal received\");\n    mailbox[header.channel] = true;\n    return;\n  }\n\n  if (header.isFirst) {\n    incomeBuffer = new Uint8Array();\n  }\n  const currentBuffer = incomeBuffer;\n  incomeBuffer = new Uint8Array(currentBuffer.length + payload.length);\n  incomeBuffer.set(currentBuffer);\n  incomeBuffer.set(payload, currentBuffer.length);\n\n  if (header.isFinished) {\n    if (header.isCompressed) {\n      throw Error(\"not supported yet\");\n    }\n    /** @type {object} */\n\n    try {\n      const data = decode(incomeBuffer);\n      // console.debug(\"HandleIncome\", data, mailbox)\n      interpretMessage(header as Header, data as number[]);\n    } catch (e) {\n      console.warn(\"error decode\", e, incomeBuffer);\n    } finally {\n      incomeBuffer = new Uint8Array();\n    }\n  }\n}\nexport async function requestDevice() {\n  console.debug(\"gateway/ device requested\");\n  if (device != null) return;\n\n  device = await window.navigator.bluetooth.requestDevice({\n    filters: [{ namePrefix: \"AnataLAB\" }],\n    optionalServices: [\n      \"0000ffe1-0000-1000-8000-00805f9b34fb\",\n      \"0000ffe0-0000-1000-8000-00805f9b34fb\",\n    ],\n  });\n  if (!device) return;\n  device.addEventListener(\"gattserverdisconnected\", () => {\n\n  \n\n    location.reload()\n\n    isInitialized = false\n    console.debug(`ble/ disconnected`, \"Red\");\n    reconnectTimeout = setTimeout(async () => {\n      if (device) {\n        await connectDevice(device);\n      }\n    }, 10000);\n    (window as any).ctx.setConnectButtonStyle(\"outline\");\n    (window as any).ctx.setConnectButtonText(\"Retrying ...\");\n    (window as any).ctx.setConnected(false);\n  });\n  await connectDevice(device);\n}\nexport async function disconnectDevice() {\n  console.debug(\"gateway/ device disconnected\");\n  if (device == null) return;\n  clearTimeout(reconnectTimeout);\n  device.gatt?.disconnect();\n  device = null;\n\n  console.debug(\"CTX\", (window as any).ctx);\n  (window as any).ctx.setConnectButtonStyle(\"outline\");\n  (window as any).ctx.setConnectButtonText(\"Connect\");\n  (window as any).ctx.setConnected(false);\n}\n\nconst splitChunk = (arr: Uint8Array, size: number) =>\n  Array.from({ length: Math.ceil(arr.length / size) }, (v, i) =>\n    arr.slice(i * size, i * size + size),\n  );\n\nconst encodeMessage = (chunk: Uint8Array, header: Header) => {\n  // generate the 4 header flags, then combine it with the chunk\n  var headerByte = 0x00;\n  if (header.isFinished) {\n    headerByte = headerByte | 0b00000001;\n  }\n  if (header.isFirst) {\n    headerByte = headerByte | 0b00000010;\n  }\n  if (header.isCompressed) {\n    headerByte = headerByte | 0b00000100;\n  }\n  if (header.requireAck) {\n    headerByte = headerByte | 0b00001000;\n  }\n\n  const headers = new Uint8Array([\n    headerByte,\n    header.channel,\n    header.payloadLength / 256,\n    header.payloadLength % 256,\n  ]);\n\n  const finalized = new Uint8Array(headers.length + chunk.length);\n  finalized.set(headers);\n  finalized.set(chunk, headers.length);\n  return finalized;\n};\n\nfunction assignRandomId(): number {\n  (window as any).randomId = (window as any).randomId || 1;\n  (window as any).randomId += 1;\n  if ((window as any).randomId > 200) {\n    (window as any).randomId = 1;\n  }\n  return (window as any).randomId;\n}\n\nexport let mailbox = {};\n\nlet isSending = false;\nexport async function queryDevice(params: any) {\n  if (!(window as any).ctx.connected) return;\n  while (isSending) {\n    await sleep(10);\n  }\n  isSending = true;\n  /*\n        main point of contact between api and device\n        encode params, split to chunk, add the header and send\n        wait for mailbox for return\n        remember to set ack flag\n    */\n  try {\n    params.id = new Date().getTime();\n    const encoded = encode(params);\n    const chunks = splitChunk(encoded, mtu - 3);\n    console.debug(`splited into ${chunks.length} chunks`);\n\n    mailbox[params.id] = null;\n\n    for (var idx = 0; idx < chunks.length; idx++) {\n      const chunk = chunks[idx];\n      const selectedChannl = assignRandomId();\n      const signed = encodeMessage(chunk, {\n        isFinished: idx == chunks.length - 1,\n        isFirst: idx == 0,\n        isCompressed: false,\n        requireAck: true,\n        channel: selectedChannl,\n        payloadLength: chunk.length,\n        frameType: 0,\n      });\n      mailbox[selectedChannl] = null;\n      await charact.writeValue(signed);\n      let startTs = new Date().getTime();\n      while (new Date().getTime() - startTs < 3000) {\n        if (mailbox[selectedChannl] != null) {\n          break;\n        }\n        await sleep(1);\n      }\n      if (mailbox[selectedChannl] == null) {\n        throw new Error(\"no ack signal received !\");\n      }\n    }\n\n    // now we wait for response\n    let futureTs = new Date().getTime() + 5000;\n    while (mailbox[params.id] == null) {\n      await sleep(1);\n      if (new Date().getTime() > futureTs) {\n        throw new Error(\"no response received !\");\n      }\n    }\n\n    let response = mailbox[params.id];\n    delete mailbox[params.id];\n\n    console.debug(\"queryDevice\", { params, response });\n\n    return response;\n  } catch (e) {\n    return null;\n  } finally {\n    isSending = false;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 626, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 631, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/calibration.ts"],"sourcesContent":["/*\n    Preferences report to State\n    Here are list of API of mapping\n*/\n\n\n\n/*\n    Calibration value are already reflected within the hardware !\n*/\n\nimport {initialState as providerInitialState} from \"@/gateway/provider\";\nimport { queryDevice } from \"./connection\";\nimport {produce} from 'immer'\n\nconst initialState = {\n    flowmeter: [1, 1, 1],\n    grinder: [1, 1, 1],\n    pid: [0,0,0]\n}\n\nconst calibration = {\n    initialState,\n}\nexport default calibration;\n\nexport async function syncCalibrationFromDevice() {\n    const request = await queryDevice({\n        command: 'calib.get',\n    });\n\n    // return {\n    //     flowmeter: request['response']['calibration']['flowmeter'] as number[],\n    //     grinder: request['response']['calibration']['grinder'] as number[],\n    //     temperature: request['response']['calibration']['temperature'] as number[],\n    // };\n\n    const ctx = (window as any).ctx as typeof providerInitialState\n    ctx.setCalibration(produce(ctx.calibration, draft => {\n        draft.flowmeter = request['response']['calibration']['flowmeter'] as number[]\n        draft.grinder = request['response']['calibration']['grinder'] as number[]\n        // draft.temperature = request['response']['calibration']['temperature'] as number[]\n        console.log('calibration/ pulled from device', request['response']['calibration'])\n        return draft\n    })\n    )\n\n    // !\n\n    // ctx.calibration = {\n    //     flowmeter: request['response']['calibration']['flowmeter'] as number[],\n    //     grinder: request['response']['calibration']['grinder'] as number[],\n    //     // temperature: request['response']['calibration']['temperature'] as number[],\n    // }\n\n}\n\nimport { isInitialized } from './connection'\n\n\nexport async function setCalibration({ flowmeter, grinder, temperature }: { flowmeter: number[], grinder: number[], temperature: number[] }) {\n    if (!isInitialized) return \n\n\n\n    return await queryDevice({\n        command: 'calib.set',\n        calibration: {\n            flowmeter,\n            grinder,\n            temperature\n        }\n    });\n}\n\n\n"],"names":[],"mappings":"AAAA;;;AAGA,GAIA;;AAEA;;;;;;;;;;AAMA,MAAM,eAAe;IACjB,WAAW;QAAC;QAAG;QAAG;KAAE;IACpB,SAAS;QAAC;QAAG;QAAG;KAAE;IAClB,KAAK;QAAC;QAAE;QAAE;KAAE;AAChB;AAEA,MAAM,cAAc;IAChB;AACJ;uCACe;AAER,eAAe;IAClB,MAAM,UAAU,MAAM,wIAAY;QAC9B,SAAS;IACb;IAEA,WAAW;IACX,8EAA8E;IAC9E,0EAA0E;IAC1E,kFAAkF;IAClF,KAAK;IAEL,MAAM,MAAM,AAAC,OAAe,GAAG;IAC/B,IAAI,cAAc,CAAC,+IAAQ,IAAI,WAAW,EAAE,CAAA;QACxC,MAAM,SAAS,GAAG,OAAO,CAAC,WAAW,CAAC,cAAc,CAAC,YAAY;QACjE,MAAM,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC,cAAc,CAAC,UAAU;QAC7D,oFAAoF;QACpF,QAAQ,GAAG,CAAC,mCAAmC,OAAO,CAAC,WAAW,CAAC,cAAc;QACjF,OAAO;IACX;AAGA,IAAI;AAEJ,sBAAsB;AACtB,8EAA8E;AAC9E,0EAA0E;AAC1E,qFAAqF;AACrF,IAAI;AAER;;AAKO,eAAe,eAAe,EAAE,SAAS,EAAE,OAAO,EAAE,WAAW,EAAqE;IACvI,IAAI,4IAAgB;IAIpB,OAAO,MAAM,wIAAY;QACrB,SAAS;QACT,aAAa;YACT;YACA;YACA;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 703, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 708, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/service_worker.ts"],"sourcesContent":["export async function registerServiceWorker() {\n  try {\n    if (location.href.includes(\"localhost\")) {\n      console.log(\"sw/ disable service worker on localhost\");\n      return;\n    }\n    setInterval(function () {\n      fetch(\"/index.html\");\n    }, 10000);\n\n    \n\n    var regitration = await navigator.serviceWorker.register(\"/sw.js\", {\n      scope: \"/\",\n    });\n\n  }\n  catch (e) {\n    console.error(e);\n  }\n}\n"],"names":[],"mappings":";;;AAAO,eAAe;IACpB,IAAI;QACF,IAAI,SAAS,IAAI,CAAC,QAAQ,CAAC,cAAc;YACvC,QAAQ,GAAG,CAAC;YACZ;QACF;QACA,YAAY;YACV,MAAM;QACR,GAAG;QAIH,IAAI,cAAc,MAAM,UAAU,aAAa,CAAC,QAAQ,CAAC,UAAU;YACjE,OAAO;QACT;IAEF,EACA,OAAO,GAAG;QACR,QAAQ,KAAK,CAAC;IAChB;AACF"}},
    {"offset": {"line": 727, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 732, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/grinder.ts"],"sourcesContent":["\"use client\";\n\nimport { queryDevice } from \"./connection\";\nimport { initialState } from \"./provider\";\n\nexport interface IGrinderState {\n  connectionType: \"Wire\" | \"Bluetooth\";\n  connectionId: number;\n  calibration: number;\n  id: number;\n  name: string;\n}\n\nexport enum EnumSkipBehaviour {\n  Skip = \"Skip\",\n  Wait = \"Wait\",\n}\n\nexport const grinderInitialState: IGrinderState[] = [\n  {\n    connectionType: \"Wire\",\n    connectionId: 20,\n    calibration: 1.17,\n    id: 0,\n    name: \"Arabica\",\n  },\n  {\n    connectionType: \"Wire\",\n    connectionId: 20,\n    calibration: 1.17,\n    id: 0,\n    name: \"Coco\",\n  },\n];\nexport class GrinderSettingParameter {\n  connectionType: \"Wire\" | \"Bluetooth\" = \"Wire\";\n  connectionId: number = 0;\n  calibration: number = 0;\n  constructor({ connectionType, connectionId, calibration }: IGrinderState) {\n    this.connectionType = connectionType;\n    this.connectionId = connectionId;\n    this.calibration = calibration;\n  }\n}\n\nexport async function setGrinderConfiguration() {\n  // map each of the pid state to this\n  const ctx = (window as any).ctx as typeof initialState;\n  const grinders = ctx.grinderSettings;\n\n  await queryDevice({\n    command: \"grinder.set\",\n    grinders,\n  });\n}\n\nexport async function getGrinderConfiguration() {\n  const req = await queryDevice({\n    command: \"grinder.get\",\n  });\n  const grinderSettings = req[\"response\"][\"grinderSettings\"];\n  console.log(\"grinder/ acquired\", grinderSettings);\n\n  const ctx = (window as any).ctx as typeof initialState;\n  // ctx.grinderSettings.forEach(draft => {\n  //     grinderSettings.set\n  // })\n  ctx.setGrinderSettings(grinderSettings);\n}\n"],"names":[],"mappings":";;;;;;;;;AAAA;;;UAaY;;;GAAA,sBAAA;AAKL,MAAM,sBAAuC;IAClD;QACE,gBAAgB;QAChB,cAAc;QACd,aAAa;QACb,IAAI;QACJ,MAAM;IACR;IACA;QACE,gBAAgB;QAChB,cAAc;QACd,aAAa;QACb,IAAI;QACJ,MAAM;IACR;CACD;AACM,MAAM;IACX,iBAAuC,OAAO;IAC9C,eAAuB,EAAE;IACzB,cAAsB,EAAE;IACxB,YAAY,EAAE,cAAc,EAAE,YAAY,EAAE,WAAW,EAAiB,CAAE;QACxE,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,WAAW,GAAG;IACrB;AACF;AAEO,eAAe;IACpB,oCAAoC;IACpC,MAAM,MAAM,AAAC,OAAe,GAAG;IAC/B,MAAM,WAAW,IAAI,eAAe;IAEpC,MAAM,wIAAY;QAChB,SAAS;QACT;IACF;AACF;AAEO,eAAe;IACpB,MAAM,MAAM,MAAM,wIAAY;QAC5B,SAAS;IACX;IACA,MAAM,kBAAkB,GAAG,CAAC,WAAW,CAAC,kBAAkB;IAC1D,QAAQ,GAAG,CAAC,qBAAqB;IAEjC,MAAM,MAAM,AAAC,OAAe,GAAG;IAC/B,yCAAyC;IACzC,0BAA0B;IAC1B,KAAK;IACL,IAAI,kBAAkB,CAAC;AACzB"}},
    {"offset": {"line": 795, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 807, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/i18n/index.js"],"sourcesContent":["var en = require(\"./translations.en.json\");\nvar vi = require(\"./translations.vi.json\");\n\nconst i18n = {\n  translations: {\n    en,\n    vi,\n  },\n  defaultLang: \"en\",\n  useBrowserDefault: true,\n  // optional property will default to \"query\" if not set\n  languageDataStore: \"localStorage\",\n};\n\nmodule.exports = i18n;\n"],"names":[],"mappings":"AAAA,IAAI,KAAK;AACT,IAAI,KAAK;AAET,MAAM,OAAO;IACX,cAAc;QACZ;QACA;IACF;IACA,aAAa;IACb,mBAAmB;IACnB,uDAAuD;IACvD,mBAAmB;AACrB;AAEA,OAAO,OAAO,GAAG"}},
    {"offset": {"line": 820, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 825, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/target.ts"],"sourcesContent":["export enum ProfileType {\n    PressureProfiling = \"PressureProfile\",\n    FlowrateProfiling = \"FlowateProfile\",\n};\nexport enum TargetType {\n    Weight = \"Weight\",\n    Time = \"Time\",\n};\nexport class Time {\n    duration: number;\n    constructor({ duration }: { duration: number }) {\n        this.duration = duration;\n    }\n    toData() {\n        return {\n            targetType: TargetType.Time,\n            duration: this.duration,\n        }\n    }\n    static fromData(data: any) {\n        return new Time({\n            duration: data.duration\n        });\n    }\n}\nexport class Weight {\n    weight: number;\n    constructor({ weight }: { weight: number }) {\n        this.weight = weight;\n    }\n    toData() {\n        return {\n            targetType: TargetType.Weight,\n            weight: this.weight,\n        }\n    }\n\n    static fromData(data: any) {\n        return new Weight({\n            weight: data.weight\n        });\n    }\n}\nexport type TargetClass = Time | Weight;\n"],"names":[],"mappings":";;;;;;;UAAY;;;GAAA,gBAAA;;UAIA;;;GAAA,eAAA;AAIL,MAAM;IACT,SAAiB;IACjB,YAAY,EAAE,QAAQ,EAAwB,CAAE;QAC5C,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA,SAAS;QACL,OAAO;YACH,UAAU;YACV,UAAU,IAAI,CAAC,QAAQ;QAC3B;IACJ;IACA,OAAO,SAAS,IAAS,EAAE;QACvB,OAAO,IAAI,KAAK;YACZ,UAAU,KAAK,QAAQ;QAC3B;IACJ;AACJ;AACO,MAAM;IACT,OAAe;IACf,YAAY,EAAE,MAAM,EAAsB,CAAE;QACxC,IAAI,CAAC,MAAM,GAAG;IAClB;IACA,SAAS;QACL,OAAO;YACH,UAAU;YACV,QAAQ,IAAI,CAAC,MAAM;QACvB;IACJ;IAEA,OAAO,SAAS,IAAS,EAAE;QACvB,OAAO,IAAI,OAAO;YACd,QAAQ,KAAK,MAAM;QACvB;IACJ;AACJ"}},
    {"offset": {"line": 875, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 880, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/action.ts"],"sourcesContent":["import { ProfileType } from \"./target\";\n\nexport enum ActionType {\n  Grinding = \"Grinding\",\n  Extracting = \"Extracting\",\n  Profiling = \"Profilling\",\n}\nexport enum ConnectionType {\n  Wire = \"Wired\",\n  Bluetooth = \"Bluetooth\",\n}\n\nexport class GrinderAction {\n  // grinder have grinderId, grinderConnection\n  grinderId: number;\n  grinderConnection: ConnectionType;\n  canSkip: boolean;\n  canWait: boolean;\n\n  constructor({\n    grinderId,\n    grinderConnection,\n    canSkip,\n    canWait,\n  }: {\n    grinderId: number;\n    grinderConnection: ConnectionType;\n    canSkip: boolean;\n    canWait: boolean;\n  }) {\n    this.grinderId = grinderId;\n    this.grinderConnection = grinderConnection;\n    this.canSkip = canSkip;\n    this.canWait = canWait;\n  }\n\n  toData() {\n    return {\n      actionType: ActionType.Grinding,\n      grinderId: this.grinderId,\n      grinderConnection: this.grinderConnection,\n      canSkip: this.canSkip,\n      canWait: this.canWait,\n    };\n  }\n\n  static fromData(data: any) {\n    return new GrinderAction({\n      grinderId: data.grinderId,\n      grinderConnection: data.grinderConnection,\n      canSkip: data.canSkip,\n      canWait: data.canWait,\n    });\n  }\n}\nexport class PumpAction {\n  power: number;\n  valveState: boolean;\n  constructor({ power, valveState }: { power: number; valveState: boolean }) {\n    this.power = power;\n    this.valveState = valveState;\n  }\n  toData() {\n    return {\n      actionType: ActionType.Extracting,\n      power: this.power,\n      valveState: this.valveState,\n    };\n  }\n\n  static fromData(data: any) {\n    return new PumpAction({\n      power: data.power,\n      valveState: data.valveState,\n    });\n  }\n}\nexport class ProfilingAction {\n  profileType: ProfileType;\n  segments: Segment[];\n  refreshInterval: number; // how fast we update\n  kp: number;\n  ki: number;\n  kd: number;\n\n  constructor({\n    profileType,\n    segments,\n    refreshInterval,\n  }: {\n    profileType: ProfileType;\n    segments: Segment[];\n    refreshInterval: number;\n  }) {\n    this.profileType = profileType;\n    this.segments = segments;\n    this.refreshInterval = refreshInterval;\n  }\n  toData() {\n    const steps: Segment[] = [];\n    this.segments.forEach((segment) => {\n      steps.push(segment);\n    });\n\n    return {\n      actionType: ActionType.Profiling,\n      profileType: this.profileType,\n      refreshInterval: this.refreshInterval,\n      segments: steps,\n    };\n  }\n  static fromData(data: any) {\n    const segments = data.segments.map((segment: any) =>\n      Segment.fromData(segment),\n    );\n    return new ProfilingAction({\n      profileType: data.profileType,\n      segments: segments,\n      refreshInterval: data.refreshInterval,\n    });\n  }\n}\nexport class Segment {\n  duration: number;\n  value: number;\n\n  constructor({ duration, value }: { duration: number; value: number }) {\n    this.duration = duration;\n    this.value = value;\n  }\n\n  toData() {\n    return {\n      duration: this.duration,\n      value: this.value,\n    };\n  }\n\n  static fromData(data: any) {\n    return new Segment({\n      duration: data.duration,\n      value: data.value,\n    });\n  }\n}\nexport type ActionClass = GrinderAction | PumpAction | ProfilingAction;\n"],"names":[],"mappings":";;;;;;;;;UAEY;;;;GAAA,eAAA;;UAKA;;;GAAA,mBAAA;AAKL,MAAM;IACX,4CAA4C;IAC5C,UAAkB;IAClB,kBAAkC;IAClC,QAAiB;IACjB,QAAiB;IAEjB,YAAY,EACV,SAAS,EACT,iBAAiB,EACjB,OAAO,EACP,OAAO,EAMR,CAAE;QACD,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,SAAS;QACP,OAAO;YACL,UAAU;YACV,WAAW,IAAI,CAAC,SAAS;YACzB,mBAAmB,IAAI,CAAC,iBAAiB;YACzC,SAAS,IAAI,CAAC,OAAO;YACrB,SAAS,IAAI,CAAC,OAAO;QACvB;IACF;IAEA,OAAO,SAAS,IAAS,EAAE;QACzB,OAAO,IAAI,cAAc;YACvB,WAAW,KAAK,SAAS;YACzB,mBAAmB,KAAK,iBAAiB;YACzC,SAAS,KAAK,OAAO;YACrB,SAAS,KAAK,OAAO;QACvB;IACF;AACF;AACO,MAAM;IACX,MAAc;IACd,WAAoB;IACpB,YAAY,EAAE,KAAK,EAAE,UAAU,EAA0C,CAAE;QACzE,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,UAAU,GAAG;IACpB;IACA,SAAS;QACP,OAAO;YACL,UAAU;YACV,OAAO,IAAI,CAAC,KAAK;YACjB,YAAY,IAAI,CAAC,UAAU;QAC7B;IACF;IAEA,OAAO,SAAS,IAAS,EAAE;QACzB,OAAO,IAAI,WAAW;YACpB,OAAO,KAAK,KAAK;YACjB,YAAY,KAAK,UAAU;QAC7B;IACF;AACF;AACO,MAAM;IACX,YAAyB;IACzB,SAAoB;IACpB,gBAAwB;IACxB,GAAW;IACX,GAAW;IACX,GAAW;IAEX,YAAY,EACV,WAAW,EACX,QAAQ,EACR,eAAe,EAKhB,CAAE;QACD,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,eAAe,GAAG;IACzB;IACA,SAAS;QACP,MAAM,QAAmB,EAAE;QAC3B,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YACrB,MAAM,IAAI,CAAC;QACb;QAEA,OAAO;YACL,UAAU;YACV,aAAa,IAAI,CAAC,WAAW;YAC7B,iBAAiB,IAAI,CAAC,eAAe;YACrC,UAAU;QACZ;IACF;IACA,OAAO,SAAS,IAAS,EAAE;QACzB,MAAM,WAAW,KAAK,QAAQ,CAAC,GAAG,CAAC,CAAC,UAClC,QAAQ,QAAQ,CAAC;QAEnB,OAAO,IAAI,gBAAgB;YACzB,aAAa,KAAK,WAAW;YAC7B,UAAU;YACV,iBAAiB,KAAK,eAAe;QACvC;IACF;AACF;AACO,MAAM;IACX,SAAiB;IACjB,MAAc;IAEd,YAAY,EAAE,QAAQ,EAAE,KAAK,EAAuC,CAAE;QACpE,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,KAAK,GAAG;IACf;IAEA,SAAS;QACP,OAAO;YACL,UAAU,IAAI,CAAC,QAAQ;YACvB,OAAO,IAAI,CAAC,KAAK;QACnB;IACF;IAEA,OAAO,SAAS,IAAS,EAAE;QACzB,OAAO,IAAI,QAAQ;YACjB,UAAU,KAAK,QAAQ;YACvB,OAAO,KAAK,KAAK;QACnB;IACF;AACF"}},
    {"offset": {"line": 1003, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1008, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/step.ts"],"sourcesContent":["import {\n  ActionClass,\n  ActionType,\n  GrinderAction,\n  ProfilingAction,\n  PumpAction,\n} from \"./action\";\nimport { TargetClass, TargetType, Time, Weight } from \"./target\";\n\n// Interim object\nexport type IStepFeedback = {\n  //\n\n  stepId: number;\n  groupId: number;\n  target: {\n    type: EnumTarget;\n    total: number;\n    value: number;\n  };\n  action: {\n    profilingType: EnumProfileType;\n    expectedValue: number;\n    timestamp: number;\n    input: number;\n    pressure: number;\n    output: number;\n  };\n};\n\nexport enum EnumTarget {\n  Time = \"Time\",\n  Weight = \"Weight\",\n}\nexport enum EnumAction {\n  Grind = \"Grind\",\n  Rest = \"Rest\",\n  Extract = \"Extract\",\n  Profile = \"Profile\",\n  PourOver = \"Pour\",\n  Sound = \"Sound\",\n  RGB = \"RGB\",\n}\n\nexport type IStep = {\n  id: string;\n  action: IAction;\n  target: ITarget;\n};\n\nexport type ITarget = {\n  targetType: EnumTarget;\n  value: number;\n  current?: number; // for reporting progress\n};\n\nexport type IPourOverParam = {\n  /* \n        Pour over \n    */\n  actionType: \"Pour\";\n  stepAmount: number;\n  duration: number;\n  pumpPower: number;\n};\nexport type ISoundParam = {\n  actionType: \"Sound\";\n};\nexport type IRGBParam = {\n  actionType: \"RGB\";\n  color: string;\n  start: number;\n  stop: number;\n  animation: string;\n\n};\n\nexport type IAction =\n  | IRestParam\n  | IGrindParam\n  | IExtractParam\n  | IProfileParam\n  | IPourOverParam\n  | ISoundParam\n  | IRGBParam;\n\nexport type IRestParam = {\n  actionType: \"Rest\";\n  valveState: boolean;\n};\n\nexport type IGrindParam = {\n  actionType: \"Grind\";\n  ingredient: string;\n  canSkip: boolean;\n  mustWait: boolean;\n};\n\nexport type IExtractParam = {\n  actionType: \"Extract\";\n  power: number;\n};\n\nexport enum EnumProfileType {\n  Pressure = \"Pressure\",\n  Flowrate = \"Flowrate\",\n  Power = \"Power\",\n}\n\nexport type IProfileParam = {\n  actionType: \"Profile\";\n  segments: IProfilingSegment[];\n  profilingType: EnumProfileType;\n  updateInterval: number;\n};\n\n\n\nexport type IProfilingSegment = {\n  duration: number;\n  value: number;\n  smooth: boolean;\n};\n\n//! Deprecated\nexport class Step {\n  action: ActionClass;\n  target: TargetClass;\n  constructor({\n    action,\n    target,\n  }: {\n    action: ActionClass;\n    target: TargetClass;\n  }) {\n    this.action = action;\n    this.target = target;\n  }\n\n  toData() {\n    return {\n      action: this.action.toData(),\n      target: this.target.toData(),\n    };\n  }\n\n  static fromData(data: any) {\n    let _action: ActionClass;\n    switch (data.actionType) {\n      case ActionType.Grinding:\n        _action = new GrinderAction(data.action);\n        break;\n      case ActionType.Extracting:\n        _action = new PumpAction(data.action);\n        break;\n      case ActionType.Profiling:\n        _action = new ProfilingAction(data.action);\n        break;\n      default:\n        _action = new GrinderAction(data.action);\n    }\n    let _target: TargetClass;\n    switch (data.targetType) {\n      case TargetType.Time:\n        _target = new Time(data.target);\n        break;\n      case TargetType.Weight:\n        _target = new Weight(data.target);\n        break;\n      default:\n        _target = new Time(data.target);\n    }\n    return new Step({\n      action: _action,\n      target: _target,\n    });\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;UA8BY;;;GAAA,eAAA;;UAIA;;;;;;;;GAAA,eAAA;;UAqEA;;;;GAAA,oBAAA;AAsBL,MAAM;IACX,OAAoB;IACpB,OAAoB;IACpB,YAAY,EACV,MAAM,EACN,MAAM,EAIP,CAAE;QACD,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;IAChB;IAEA,SAAS;QACP,OAAO;YACL,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM;YAC1B,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM;QAC5B;IACF;IAEA,OAAO,SAAS,IAAS,EAAE;QACzB,IAAI;QACJ,OAAQ,KAAK,UAAU;YACrB,KAAK,mIAAW,QAAQ;gBACtB,UAAU,0IAAkB,KAAK,MAAM;gBACvC;YACF,KAAK,mIAAW,UAAU;gBACxB,UAAU,uIAAe,KAAK,MAAM;gBACpC;YACF,KAAK,mIAAW,SAAS;gBACvB,UAAU,4IAAoB,KAAK,MAAM;gBACzC;YACF;gBACE,UAAU,0IAAkB,KAAK,MAAM;QAC3C;QACA,IAAI;QACJ,OAAQ,KAAK,UAAU;YACrB,KAAK,mIAAW,IAAI;gBAClB,UAAU,iIAAS,KAAK,MAAM;gBAC9B;YACF,KAAK,mIAAW,MAAM;gBACpB,UAAU,mIAAW,KAAK,MAAM;gBAChC;YACF;gBACE,UAAU,iIAAS,KAAK,MAAM;QAClC;QACA,OAAO,IAAI,KAAK;YACd,QAAQ;YACR,QAAQ;QACV;IACF;AACF"}},
    {"offset": {"line": 1085, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1090, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/formula.ts"],"sourcesContent":["import { initialState } from \"@/gateway/provider\";\nimport { produce } from \"immer\";\nimport { queryDevice } from \"./connection\";\nimport { EnumAction, IStep, Step } from \"./step\";\nimport { FaMapLocation } from \"react-icons/fa6\";\n\nexport enum EnumFormulaType {\n  Espresso = \"Espresso\",\n  Teapresso = \"Teapresso\",\n  PourOver = \"PourOver\",\n}\n\nexport class Formula {\n  steps: Step[];\n  name?: string;\n  uuid?: number;\n  createdAt?: number;\n  lastUsed?: number;\n  totalUsed?: number;\n\n  constructor({\n    steps,\n    name,\n    uuid,\n    createdAt,\n    lastUsed,\n    totalUsed,\n  }: {\n    steps: Step[];\n    name?: string;\n    uuid?: number;\n    createdAt?: number;\n    lastUsed?: number;\n    totalUsed?: number;\n  }) {\n    this.steps = steps;\n    this.name = name;\n    this.uuid = uuid;\n    this.createdAt = createdAt;\n    this.lastUsed = lastUsed;\n    this.totalUsed = totalUsed;\n  }\n  toData() {\n    const steps: Step[] = [];\n    this.steps.forEach((step) => {\n      steps.push(step);\n    });\n    return {\n      steps: steps,\n      name: this.name,\n      uuid: this.uuid,\n      createdAt: this.createdAt,\n      lastUsed: this.lastUsed,\n      totalUsed: this.totalUsed,\n    };\n  }\n\n  fromData(data: any) {\n    const steps = data.steps.map((step: any) => Step.fromData(step));\n    return new Formula({\n      steps: steps,\n      name: data.name,\n      uuid: data.uuid,\n      createdAt: data.createdAt,\n      lastUsed: data.lastUsed,\n      totalUsed: data.totalUsed,\n    });\n  }\n}\n\nexport async function clearGroupFormula({\n  groupId,\n  buttonId,\n}: {\n  groupId: number;\n  buttonId: number;\n}) {\n  return await queryDevice({\n    command: \"group.clear\",\n    groupId,\n    buttonId,\n  });\n}\nexport async function writeGroupFormula({\n  groupId,\n  buttonId,\n  formula,\n}: {\n  groupId: number;\n  buttonId: number;\n  formula: object;\n}) {\n  return await queryDevice({\n    command: \"group.write\",\n    groupId,\n    buttonId,\n    formula,\n  });\n}\n\nexport async function saveGroupFormula({\n  groupId,\n  buttonId,\n}: {\n  groupId: number;\n  buttonId: number;\n}) {\n  return await queryDevice({\n    command: \"group.save\",\n    groupId,\n    buttonId,\n  });\n}\n\nexport async function loadGroupFormula({\n  groupId,\n  buttonId,\n}: {\n  groupId: number;\n  buttonId: number;\n}) {\n  return await queryDevice({\n    command: \"group.load\",\n    groupId,\n    buttonId,\n  });\n}\n\nexport async function readGroupFormula({\n  groupId,\n  buttonId,\n}: {\n  groupId: number;\n  buttonId: number;\n}) {\n  return await queryDevice({\n    command: \"group.read\",\n    groupId,\n    buttonId,\n  });\n}\n\nexport async function runGroupFormula({\n  groupId,\n  buttonId,\n}: {\n  groupId: number;\n  buttonId: number;\n}) {\n\n  return await queryDevice({\n    command: \"group.run\",\n    groupId,\n    buttonId,\n  });\n}\n\nfunction convertSteps(steps: IStep[]) {\n  /*\n    There are bugs in the Runes of NewStepCard that keep messing this up\n    This is a clean workaround\n  */\n  const cvts: any = [];\n  for (const step of steps) {\n    // if (step.action.actionType == 'Rest') {\n    //   const action = step.action as IRestParam\n    //   action.valveState = action.valveState * 1000\n    // }\n    const cvt: any = {};\n    cvt.action = {};\n    cvt.target = {};\n    cvts.push(cvt);\n\n    const mock = 1; // send raw valu \n\n\n    if (step.action.actionType == EnumAction.Rest) {\n      cvt.action.actionType = \"Rest\";\n      cvt.action.valveState = step.action.valveState || true;\n      cvt.target.targetType = \"Time\";\n      cvt.target.value = step.target.value * 1000 || 0;\n    } else if (step.action.actionType == EnumAction.Extract) {\n      cvt.action.actionType = \"Extract\";\n      cvt.action.power = step.action.power || 0;\n      cvt.target.targetType = \"Weight\";\n      cvt.target.value = step.target.value * mock || 0;\n    } else if (step.action.actionType == EnumAction.Grind) {\n      cvt.action.actionType = \"Grind\";\n      // cvt.action.power = step.action.power;\n      cvt.action.ingredient = step.action.ingredient || \"\";\n      cvt.action.canSkip = step.action.canSkip || false;\n      cvt.target.targetType = \"Weight\";\n      cvt.target.value = step.target.value * mock || 0;\n\n    } else if (step.action.actionType == EnumAction.PourOver) {\n      cvt.action.actionType = \"Pour\"\n      cvt.action.stepAmount = step.action.stepAmount\n      cvt.action.duration = step.action.duration * 1000\n      cvt.action.pumpPower = step.action.pumpPower\n      cvt.target.targetType = \"Weight\"\n      cvt.target.value = step.target.value * mock || 0\n    } else if (step.action.actionType == EnumAction.RGB) {\n      cvt.action.actionType = \"RGB\"\n      cvt.action.color = step.action.color\n      cvt.action.start = step.action.start\n      cvt.action.stop = step.action.stop\n\n\n      \n    } else if (step.action.actionType == EnumAction.Profile) {\n      cvt.action.actionType = \"Profile\";\n      cvt.action.segments = step.action.segments || [];\n      cvt.action.profilingType = step.action.profilingType;\n      cvt.target.targetType = \"Weight\";\n      cvt.target.value = step.target.value * mock || 0;\n      // loop through each segment, the duration must all be *1000 (miliseconds)\n      // clone the array\n      const clonedSegments = JSON.parse(JSON.stringify(cvt.action.segments));\n\n      // transform the smooth and timescale\n      const transformedSegments: any[] = []\n      for (const segment of clonedSegments) {\n        if (segment.smooth == false) {\n          console.log(\"add the smooth segments\")\n          transformedSegments.push({\n            duration: 1,\n            value: segment.value\n          })\n          transformedSegments.push({\n            duration: segment.duration * 1000,\n            value: segment.value\n          })\n        }\n        else {\n          transformedSegments.push({\n            duration: segment.duration * 1000,\n            value: segment.value\n          })\n        }\n      }\n\n\n\n      cvt.action.segments = transformedSegments;\n      console.log(\"segments\", transformedSegments);\n    }\n\n    // if (step.target.targetType == EnumTarget.Time) {\n    //   step.target.value = step.target.value * 1000\n    // }\n    // else if (step.target.targetType == EnumTarget.Weight) {\n    //   step.target.value *= 100\n    // }\n  }\n  return cvts;\n}\n\n\nexport async function cancelRunningFormula(groupId: number) {\n  await queryDevice({\n    command: \"group.cancel\",\n    groupId: groupId,\n  });\n}\n\nconst formulaClickQueue = {};\nconst groupRunningFormulaId = {}\nlet formulaClickQueueTimeout: ReturnType<typeof setTimeout>;\nexport function registerFormulaClick(formulaId: string) {\n  formulaClickQueue[formulaId] = formulaClickQueue[formulaId] || 0;\n  formulaClickQueue[formulaId] += 1;\n  clearTimeout(formulaClickQueueTimeout);\n  formulaClickQueueTimeout = setTimeout(async () => {\n    for (const key in formulaClickQueue) {\n      const groupId = formulaClickQueue[key];\n      const formulaId = key;\n      console.log(\n        \"provider/ registerFormulaClick\",\n        key,\n        formulaClickQueue[key],\n      );\n\n      groupRunningFormulaId[key] = groupId;\n\n      // clear the feedback of the current chart\n      (window as any).fbstore = [];\n\n      await runFormula({\n        formulaId: key,\n        groupId: formulaClickQueue[key],\n      });\n\n      delete formulaClickQueue[key];\n    }\n  }, 1000);\n}\n\nexport async function cancelFormulaClick(formulaId: string) {\n  console.log(\"provider/ cancelFormulaClick\", formulaId);\n  clearTimeout(formulaClickQueueTimeout);\n\n\n\n  setTimeout(async () => {\n    // await cancelRunningFormula(1);\n    // await cancelRunningFormula(2);\n\n    await cancelRunningFormula(groupRunningFormulaId[formulaId])\n    delete groupRunningFormulaId[formulaId]\n\n  });\n}\nexport async function downloadFormula({\n  groupId, buttonId, formulaId\n}: {\n  groupId: number\n  buttonId: number\n  formulaId: string\n}) {\n\n  const ctx = (window as any).ctx as typeof initialState\n  const steps = ctx.formulas[formulaId].steps;\n  const convertedSteps = convertSteps(steps);\n\n  const fm = JSON.parse(JSON.stringify(ctx.formulas[formulaId]))\n  fm.steps = convertedSteps\n  fm.buildupDuration *= 1000;\n  console.warn(\"Formula\");\n  console.warn(JSON.stringify(fm, null, 2));\n\n  await writeGroupFormula({\n    groupId,\n    buttonId,\n    formula: fm\n  })\n  await saveGroupFormula({ groupId, buttonId })\n}\n\n\nexport async function runFormula({\n  formulaId,\n  groupId,\n}: {\n  formulaId: string;\n  groupId: number;\n}) {\n  const ctx = (window as any).ctx as typeof initialState;\n  const steps = ctx.formulas[formulaId].steps;\n  if (groupId > 3 || groupId < 1) return;\n  // const steps = (JSON.parse(localStorage.getItem(formulaId)) as IStep[]) || [];\n\n  console.log(\n    `device/ run the formula, load from LS on GROUP ${groupId}`,\n    steps,\n  );\n\n  const convertedSteps = convertSteps(steps);\n  \n\n  console.log(\"device/ run the formula\");\n  console.log(JSON.stringify(convertedSteps, null, 2));\n\n  // clear the formulaFeedbacks\n  ctx.setFeedbacks(\n    produce(ctx.formulaFeedbacks, (draft) => {\n      draft[formulaId] = {};\n      return draft;\n    }),\n  );\n\n  await queryDevice({\n    command: \"group.cancel\",\n    groupId: groupId,\n  });\n\n\n\n\n  const fm = JSON.parse(JSON.stringify(ctx.formulas[formulaId]))\n  fm.buildupDuration *= 1000;\n  fm.steps = convertedSteps\n  fm.formulaId = formulaId;\n  console.warn(\"Formula\");\n  console.warn(JSON.stringify(fm, null, 2));\n\n\n\n\n\n  await queryDevice({\n    command: \"group.write\",\n    groupId: groupId,\n    buttonId: 0, // control button\n    formula: fm,\n  });\n\n  await queryDevice({\n    command: \"group.run\",\n    groupId: groupId,\n    buttonId: 0,\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1381, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1386, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/gateway/provider.tsx"],"sourcesContent":["\"use client\";\n\nimport { cancelFormulaClick, registerFormulaClick, downloadFormula } from \"@/gateway/formula\";\nimport { produce } from \"immer\";\nimport { useSelectedLanguage, useTranslation } from \"next-export-i18n\";\nimport { useRouter } from \"next/router\";\nimport { createContext, useEffect, useMemo, useState } from \"react\";\nimport { Layouts } from \"react-grid-layout\";\nimport { useEffectOnce, useLocalStorage } from \"usehooks-ts\";\nimport { EnumFormulaType } from \"./formula\";\nimport {\n  IGrinderState,\n  grinderInitialState,\n  setGrinderConfiguration,\n} from \"./grinder\";\nimport {\n  IPidDisplay,\n  IPidState,\n  PidSettingParameter,\n  syncPidStatus,\n  pidInitialDisplay,\n  pidInitialState,\n  setPidConfiguration,\n} from \"./pid\";\nimport { IProgressReport } from \"./progress\";\nimport { registerServiceWorker } from \"./service_worker\";\nimport { EnumTarget, IStep, IStepFeedback } from \"./step\";\nimport calibration, { setCalibration } from \"./calibration\";\n\nasync function sleep(ms: number) {\n  await new Promise((rs, _) => setTimeout(rs, ms));\n}\n\nexport function switchLocales(locale: string) {\n  console.log('switchLocales', locale)\n  // copied from next-export-i18n / LanguageSwitcher\n  window.localStorage.setItem(\"next-export-i18n-lang\", locale);\n  const event = new Event(\"localStorageLangChange\");\n  document.dispatchEvent(event);\n}\n\n// This dictionary holds the function references\nexport const initialState = {\n  calibration: {\n    flowmeter: new Array(3).fill(1),\n    grinder: new Array(3).fill(1),\n    pressure: new Array(4).fill(1.2)\n  },\n  setCalibration: (calibration: any) => { },\n\n\n\n  flowmeterDisplay: new Array(3).fill({\n    flowRate: 0,\n    flowCount: 0\n  }),\n  setFlowmeterDisplay: (flowmeterDisplay: any) => { },\n  flowCount: new Array(3).fill(0),\n  flowRate: new Array(3).fill(0),\n  pressure: new Array(4).fill(0),\n  setPressure: (pressure: number[]) => {},\n  connectButtonStyle: \"outline\",\n  connectButtonText: \"Connect\",\n  selectedPage: \"Formula\",\n  pidState: pidInitialState,\n  formulas: {} as Record<string, DisplayFormulaParam>,\n  setPidState: (pidState: IPidState[]) => { },\n  pidDisplay: pidInitialDisplay,\n  setPidDisplay: (pidState: IPidDisplay[]) => { },\n  connected: false,\n  grinderSettings: grinderInitialState,\n  setGrinderSettings: (grinderSettings: IGrinderState[]) => { },\n  setFlowCount: (flowCount: number[]) => { },\n  setFlowRate: (flowRate: number[]) => { },\n  registerFormulaClick: registerFormulaClick,\n  cancelFormulaClick: cancelFormulaClick,\n  downloadFormula: downloadFormula,\n  selectedFormulaId: \"\",\n  registerSelectedFormulaId: (formulaId: string) => { },\n  setFormulas: (formulas: Record<string, DisplayFormulaParam>) => { },\n  setLayout: (layout: Layouts) => { },\n  setSelectedPage: (page: string) => { },\n  layout: {} as Layouts,\n  // steps: [] as IStep[],\n  // setSteps: (steps: IStep[]) => {},\n  darkMode: false,\n  setDarkMode: (darkMode: boolean) => { },\n  language: \"en\",\n  setLanguage: (language: string) => { },\n  draggable: false,\n  setDraggable: (draggable: boolean) => { },\n\n  addFormulaOpen: false,\n  setAddFormulaOpen: (state: boolean) => { },\n  style: {\n    background: \"bg-white\",\n    hightlight: \"orange-800\",\n    primary: \"purple-800\",\n  },\n  setStyle: (style: any) => { },\n\n  progressReport: {} as Record<string, IProgressReport>,\n  setProgressReport: (progressReport: Record<string, IProgressReport>) => { },\n  formulaFeedbacks: {} as Record<string, Record<number, IStepFeedback>>,\n  formulaUpdatedTimestamp: {} as Record<string, number>,\n  setformulaUpdatedTimestamp: (formulaUpdatedTimestamp: Record<string, number>) => { },\n  setFeedbacks: (\n    formulaFeedbacks: Record<string, Record<number, IStepFeedback>>,\n  ) => { },\n\n\n  modalDisplay: false,\n  setModalDisplay: (modalDisplay: boolean) => { },\n\n  switchLocales: switchLocales,\n};\n\nlet updateFlag = {\n  pidState: false,\n  grinderState: false,\n  calibrationState: false\n};\nconst manageSync = async () => {\n  // const ctx = (window as any).ctx as typeof initialState;\n  const ctx = (window as any).ctx as typeof initialState;\n  if (updateFlag.pidState) {\n    updateFlag.pidState = false;\n    console.log(\"Update PID\", ctx.pidState);\n    for (var channel = 0; channel < 3; channel++) {\n      const pid = new PidSettingParameter({\n        proportional: ctx.pidState[channel].proportional,\n        integral: ctx.pidState[channel].integral,\n        derivative: ctx.pidState[channel].derivative,\n        targetTemperature: ctx.pidState[channel].targetTemperature,\n        activeRange: ctx.pidState[channel].activeRange,\n        isActive: ctx.pidState[channel].isActive,\n      });\n      console.log(\"sync/ pid query to device\", pid);\n      await setPidConfiguration({ channel, pid });\n    }\n  }\n  if (updateFlag.grinderState) {\n    updateFlag.grinderState = false;\n    console.log(\"topic/ update grinder settings\");\n    await setGrinderConfiguration();\n  }\n\n  if (updateFlag.calibrationState) {\n    updateFlag.calibrationState = false\n    console.log('topic/ update calibration settings')\n    await setCalibration({\n      flowmeter: ctx.calibration.flowmeter,\n      grinder: ctx.calibration.grinder,\n      temperature: [0, 0, 0]\n    })\n  }\n};\nconst managePull = async () => {\n  // handle the pulling of data, mostly the pid every 5 seconds to update the chart state\n\n  const ctx = (window as any).ctx as typeof initialState;\n  try {\n    for (var channel = 0; channel < 3; channel++) {\n      await syncPidStatus({ channel });\n    }\n  } catch (e) {\n    console.error(e);\n  }\n};\n\n// async function simulateFormulaClick(groupId: number, formulaId: string) {\n//   const ctx = (window as any).ctx as typeof initialState;\n//   // repeat 5 times\n//   ctx.setProgressReport(\n//     produce(ctx.progressReport, (draft: Record<string, IProgressReport>) => {\n//       draft[formulaId] = draft[formulaId] || ({} as IProgressReport);\n//       draft[formulaId].isRunning = true;\n//       return draft;\n//     }),\n//   );\n\n//   await sleep(5000);\n//   ctx.setProgressReport(\n//     produce(ctx.progressReport, (draft: Record<string, IProgressReport>) => {\n//       draft[formulaId] = draft[formulaId] || ({} as IProgressReport);\n//       draft[formulaId].isRunning = false;\n//       return draft;\n//     }),\n//   );\n// }\n\nexport const DeviceContext = createContext(initialState);\n\nexport type IFeedbackReport = {\n  // this is what device send to ui\n};\nexport function handleFeedback(data: any) {\n  console.log(\"Report/\", JSON.stringify(data, null, 2));\n  const ctx = (window as any).ctx as typeof initialState;\n\n  const { formulaId, stepId, target, action } = data as {\n    formulaId: string;\n    stepId: number;\n    target: {\n      type: EnumTarget;\n      total: number;\n      value: number;\n    };\n    action: {\n      profilingType: string;\n      expectedValue: number;\n      timestamp: number;\n      input: number;\n      output: number;\n    };\n  };\n  // const { type, total, value } = target;\n\n  if (data.command == \"rp.start\" && data.isLocal == true) {\n    ctx.setModalDisplay(true)\n    try {\n      (window as any).startMissionControl(data)\n\n    }\n    catch (e) {\n      console.error(e)\n    }\n\n  }\n  else if (data.command == \"rp.finish\") {\n    (window as any).finishMissionControl()\n    // setTimeout(() => {\n    //   ctx.setModalDisplay(false)\n\n    // }, 10000)\n  }\n  else if (data.command == \"rp.progress\") {\n    // update the progress locally\n    if (ctx.modalDisplay) {\n      // stream to mission control, don't set any feedbacks\n      \n      try {\n        (window as any).updateMissionControl(data)\n\n      }\n      catch (e) {\n        \n      }\n      return;\n    }\n  }\n\n\n  ctx.setformulaUpdatedTimestamp(produce(ctx.formulaUpdatedTimestamp, (draft) => {\n    draft[data.formulaId] = new Date().getTime()\n    return draft\n  }))\n\n  ctx.setFeedbacks(\n    produce(ctx.formulaFeedbacks, (draft) => {\n      // draft[formulaId][stepId].target = target\n      const formulaUpdate: Record<number, IStepFeedback> = draft[formulaId] || {};\n      draft[formulaId] = formulaUpdate;\n\n      // mofify the step of the formula update\n      formulaUpdate[stepId] = formulaUpdate[stepId] || ({} as IStepFeedback);\n      formulaUpdate[stepId].target = target;\n      formulaUpdate[stepId].action = action as IStepFeedback[\"action\"];\n\n\n      return draft;\n    }),\n  );\n  console.log(\"Update/ : Set formulaUpdatedTimestamp to \", data.formulaId)\n}\n\nexport type DisplayFormulaParam = {\n  id: string;\n  title: string;\n  text: string;\n  color: string;\n  backdrop: string;\n  formulaType: EnumFormulaType;\n  steps: IStep[];\n  buildupDuration: number;\n  lossyWeight: number; // amount of water that is lost, convertSteps will add this to the last step\n  maximumDuration: number;\n  isShared: boolean;\n  category: string;\n};\n\nexport function DeviceProvider({ children }) {\n  const { t } = useTranslation();\n  const [connectButtonStyle, setConnectButtonStyle] = useState(\n    initialState.connectButtonStyle,\n  );\n  const [connectButtonText, setConnectButtonText] = useState(t(\"Connect\"));\n  const [connected, setConnected] = useState(initialState.connected);\n  const [selectedFormulaId, registerSelectedFormulaId] =\n    useLocalStorage<string>(\"rapp-selectedFormulaId\", \"\");\n\n  const { lang } = useSelectedLanguage();\n  const [calibration, setCalibration] = useState(initialState.calibration)\n  const [formulaUpdatedTimestamp, setformulaUpdatedTimestamp] = useState(initialState.formulaUpdatedTimestamp)\n\n  useEffect(() => {\n    if (lang == \"en\" && !connected) {\n      setConnectButtonText(\"Connect\");\n    } else if (lang == \"vi\" && !connected) {\n      setConnectButtonText(\"Kt ni\");\n    }\n  }, [lang, connected]);\n\n  const [formulas, setFormulas] = useLocalStorage<\n    Record<string, DisplayFormulaParam>\n  >(\"rapp-fml\", {});\n\n  const [formulaFeedbacks, setFeedbacks] = useState<\n    Record<string, Record<number, IStepFeedback>>\n  >({});\n\n  const [layout, setLayout] = useLocalStorage<Layouts>(\"rapp-layout\", {});\n  // const { toast } = usseToast();\n  //   (window as any).toast = toast\n\n  const router = useRouter();\n  const pathMapping = {\n    \"/\": \"Formula\",\n    \"/lab\": \"Alchemy\",\n    \"/setting\": \"Setting\",\n  };\n  const initialSelectedPage = pathMapping[router.pathname];\n  console.log(`map/ set initialSelectedPage to ${initialSelectedPage}`);\n  const [selectedPage, setSelectedPage] = useState(initialSelectedPage);\n  const [pidState, setPidState] = useState<IPidState[]>(initialState.pidState);\n  const [pidDisplay, setPidDisplay] = useState<IPidDisplay[]>(\n    initialState.pidDisplay,\n  );\n  const [grinderSettings, setGrinderSettings] = useState<IGrinderState[]>(\n    initialState.grinderSettings,\n  );\n  const [darkMode, setDarkMode] = useLocalStorage<boolean>(\"darkMode\", false);\n  const [language, setLanguage] = useLocalStorage<string>(\"language\", \"en\");\n  const [draggable, setDraggable] = useState(\n    Object.entries(formulas).length == 0,\n  );\n  // const [steps, setSteps] = useState<IStep[]>([]);\n  const [style, setStyle] = useState(initialState.style);\n  const [flowCount, setFlowCount] = useState(initialState.flowCount);\n  const [flowRate, setFlowRate] = useState(initialState.flowRate);\n    const [pressure, setPressure] = useState(initialState.pressure)\n  const [flowmeterDisplay, setFlowmeterDisplay] = useState(initialState.flowmeterDisplay)\n\n  const [modalDisplay, setModalDisplay] = useState<boolean>(false);\n\n  const [addFormulaOpen, setAddFormulaOpen] = useState(false);\n  useEffect(() => {\n    if (darkMode) {\n      document.body.classList.add(\"dark\");\n    } else {\n      document.body.classList.remove(\"dark\");\n    }\n  }, [darkMode]);\n\n  const [progressReport, setProgressReport] = useState<\n    Record<string, IProgressReport>\n  >({});\n\n  // useEffect(() => {\n  //   manageSync({ ctx, connected });\n  // }, [connected]);\n\n  const value = useMemo(\n    () => ({\n      connectButtonStyle,\n      connectButtonText,\n      selectedPage,\n      pidState,\n      pidDisplay,\n      connected,\n      grinderSettings,\n      selectedFormulaId,\n      formulas,\n      layout,\n      calibration,\n      // steps,\n      darkMode,\n      language,\n      draggable,\n      style,\n      addFormulaOpen,\n      progressReport,\n      formulaFeedbacks,\n      flowmeterDisplay,\n      setformulaUpdatedTimestamp,\n      formulaUpdatedTimestamp,\n      modalDisplay,\n      setModalDisplay,\n      pressure, \n      setPressure\n\n    }),\n    [\n      grinderSettings,\n      connected,\n      connectButtonStyle,\n      connectButtonText,\n      selectedPage,\n      pidState,\n      pidDisplay,\n      selectedFormulaId,\n      formulas,\n      layout,\n      calibration,\n      // steps,\n      draggable,\n      language,\n      darkMode,\n      style,\n      addFormulaOpen,\n      progressReport,\n      formulaFeedbacks,\n      flowmeterDisplay,\n      setformulaUpdatedTimestamp,\n      formulaUpdatedTimestamp,\n      setModalDisplay,\n      modalDisplay,\n      pressure, \n      setPressure\n\n    ],\n  );\n\n  const setValue = useMemo(\n    () => ({\n      setConnected,\n      setConnectButtonStyle,\n      setConnectButtonText,\n      setSelectedPage,\n      setPidState,\n      setPidDisplay,\n      setGrinderSettings,\n      registerFormulaClick,\n      cancelFormulaClick,\n      downloadFormula,\n      registerSelectedFormulaId,\n      setLayout,\n      setFormulas,\n      setCalibration,\n      // setSteps,\n      setDarkMode,\n      setLanguage,\n      setDraggable,\n      setStyle,\n      setAddFormulaOpen,\n      setProgressReport,\n      setFeedbacks,\n      switchLocales,\n      setFlowCount,\n      setFlowRate,\n      setFlowmeterDisplay,\n    }),\n    [\n      setConnected,\n      setConnectButtonStyle,\n      setConnectButtonText,\n      setSelectedPage,\n      setPidState,\n      setPidDisplay,\n      setGrinderSettings,\n      registerSelectedFormulaId,\n      setLayout,\n      setFormulas,\n      // setSteps,\n      setDarkMode,\n      setLanguage,\n      setDraggable,\n      setStyle,\n      setAddFormulaOpen,\n      setProgressReport,\n      setFeedbacks,\n      setFlowCount,\n      setFlowRate,\n      setFlowmeterDisplay,\n    ],\n  );\n\n  const props = useMemo(() => ({ ...value, ...setValue }), [setValue, value]);\n\n  useEffect(() => {\n    (window as any).ctx = props;\n  }, [props]);\n\n  useEffect(() => {\n    updateFlag.pidState = true; // mark that pid is updated, so a sync will be pending\n  }, [pidState, setPidState]);\n\n  useEffect(() => {\n    updateFlag.calibrationState = true\n  }, [calibration])\n\n  useEffect(() => {\n    updateFlag.grinderState = true;\n  }, [grinderSettings, setGrinderSettings]);\n\n  useEffectOnce(() => {\n    // dont use useEffect, it will create 3 intervals\n    var win = (window as any)\n\n    if (win.syncInterval) clearInterval(win.syncInterval);\n    win.syncInterval = setInterval(async () => await manageSync(), 5000);\n\n\n    // create a private key\n\n\n    if (win.pullInterval) clearInterval(win.pullInterval);\n    win.pullInterval = setInterval(async () => await managePull(), 10000);\n\n    setTimeout(async () => {\n      await registerServiceWorker();\n    }, 1000);\n\n    window.addEventListener('keydown', (evt) => {\n      if (evt.ctrlKey) {\n        if (evt.key == 'k') {\n           setModalDisplay(true)\n        }\n       }\n     });\n\n\n  });\n\n  // Todo: fix later, too lzay\n  const contextValue = {\n    ...props,\n    flowCount: [],\n    flowRate: [],\n  };\n\n  return (\n    <DeviceContext.Provider value={contextValue}>{children}</DeviceContext.Provider>\n  );\n}\nexport default DeviceContext;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1843, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1848, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/pages/_app.tsx"],"sourcesContent":["'use client'\nimport '@/styles/globals.css';\n\n\nimport \"@buildo/bento-design-system/index.css\";\nimport \"@/styles/bento.css\"\n\nimport { DeviceProvider } from '@/gateway/provider';\nimport { BentoProvider } from \"@buildo/bento-design-system\";\nimport { defaultMessages } from \"@buildo/bento-design-system/lib/defaultMessages/en\";\nimport { NextUIProvider } from \"@nextui-org/react\";\nimport type { AppProps } from \"next/app\";\n\n\nfunction App({ Component, pageProps }: AppProps) {\n\n  const overrideTheme = {\n    background: '#000000'\n  }\n  return (\n    <div id=\"app\">\n      <BentoProvider defaultMessages={defaultMessages}  >\n        <NextUIProvider>\n          <DeviceProvider>\n            <Component {...pageProps} />\n          </DeviceProvider>\n        </NextUIProvider>\n      </BentoProvider>\n\n    </div>\n  );\n}\n\n\n\nimport { withTranslation } from \"react-i18next\";\nimport { useEffect } from 'react';\nexport default withTranslation()(App);"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;;;;;;;;;AAcA,SAAS,IAAI,EAAE,SAAS,EAAE,SAAS,EAAY;IAE7C,MAAM,gBAAgB;QACpB,YAAY;IACd;IACA,qBACE,qJAAC;QAAI,IAAG;kBACN,cAAA;YAAe,eAAe;sBAC5B,cAAA;0BACE,cAAA;8BACE,cAAA,qJAAC;wBAAW,GAAG,SAAS;;;;;;;;;;;;;;;;;;;;;;;;;;AAOpC;KAjBS;;uCAuBM,mLAAkB"}},
    {"offset": {"line": 1913, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1917, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/entry/page-loader.ts"],"sourcesContent":["const PAGE_PATH = \"/_app\";\n\n// inserted by rust code\ndeclare const PAGE_PATH: string\n\n  // Adapted from https://github.com/vercel/next.js/blob/canary/packages/next/build/webpack/loaders/next-client-pages-loader.ts\n;(window.__NEXT_P = window.__NEXT_P || []).push([\n  PAGE_PATH,\n  () => {\n    return require('PAGE')\n  },\n])\nif (module.hot) {\n  module.hot.dispose(function () {\n    window.__NEXT_P.push([PAGE_PATH])\n  })\n}\n"],"names":[],"mappings":"AAAA,MAAM,YAAY;AAMjB,CAAC,OAAO,QAAQ,GAAG,OAAO,QAAQ,IAAI,EAAE,EAAE,IAAI,CAAC;IAC9C;IACA;QACE,OAAO;IACT;CACD;AACD,IAAI,OAAO,GAAG,EAAE;IACd,OAAO,GAAG,CAAC,OAAO,CAAC;QACjB,OAAO,QAAQ,CAAC,IAAI,CAAC;YAAC;SAAU;IAClC;AACF"}},
    {"offset": {"line": 1931, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1936, "column": 0}, "map": {"version":3,"sources":["/turbopack/[turbopack]/dev/client/websocket.ts"],"sourcesContent":["// Adapted from https://github.com/vercel/next.js/blob/canary/packages/next/client/dev/error-overlay/websocket.ts\n\nlet source: WebSocket;\nconst eventCallbacks: ((msg: WebSocketMessage) => void)[] = [];\n\n// TODO: add timeout again\n// let lastActivity = Date.now()\n\nfunction getSocketProtocol(assetPrefix: string): string {\n  let protocol = location.protocol;\n\n  try {\n    // assetPrefix is a url\n    protocol = new URL(assetPrefix).protocol;\n  } catch (_) {}\n\n  return protocol === \"http:\" ? \"ws\" : \"wss\";\n}\n\nexport type WebSocketMessage =\n  | {\n      type: \"turbopack-connected\";\n    }\n  | {\n      type: \"turbopack-message\";\n      data: Record<string, any>;\n    };\n\nexport function addMessageListener(cb: (msg: WebSocketMessage) => void) {\n  eventCallbacks.push(cb);\n}\n\nexport function sendMessage(data: any) {\n  if (!source || source.readyState !== source.OPEN) return;\n  return source.send(data);\n}\n\nexport type HMROptions = {\n  path: string;\n  assetPrefix: string;\n  timeout?: number;\n  log?: boolean;\n};\n\nexport function connectHMR(options: HMROptions) {\n  const { timeout = 5 * 1000 } = options;\n\n  function init() {\n    if (source) source.close();\n\n    console.log(\"[HMR] connecting...\");\n\n    function handleOnline() {\n      const connected = { type: \"turbopack-connected\" as const };\n      eventCallbacks.forEach((cb) => {\n        cb(connected);\n      });\n\n      if (options.log) console.log(\"[HMR] connected\");\n      // lastActivity = Date.now()\n    }\n\n    function handleMessage(event: MessageEvent) {\n      // lastActivity = Date.now()\n\n      const message = {\n        type: \"turbopack-message\" as const,\n        data: JSON.parse(event.data),\n      };\n      eventCallbacks.forEach((cb) => {\n        cb(message);\n      });\n    }\n\n    // let timer: NodeJS.Timeout\n\n    function handleDisconnect() {\n      source.close();\n      setTimeout(init, timeout);\n    }\n\n    const { hostname, port } = location;\n    const protocol = getSocketProtocol(options.assetPrefix || \"\");\n    const assetPrefix = options.assetPrefix.replace(/^\\/+/, \"\");\n\n    let url = `${protocol}://${hostname}:${port}${\n      assetPrefix ? `/${assetPrefix}` : \"\"\n    }`;\n\n    if (assetPrefix.startsWith(\"http\")) {\n      url = `${protocol}://${assetPrefix.split(\"://\")[1]}`;\n    }\n\n    source = new window.WebSocket(`${url}${options.path}`);\n    source.onopen = handleOnline;\n    source.onerror = handleDisconnect;\n    source.onmessage = handleMessage;\n  }\n\n  init();\n}\n"],"names":[],"mappings":"AAAA,iHAAiH;;;;;;AAEjH,IAAI;AACJ,MAAM,iBAAsD,EAAE;AAE9D,0BAA0B;AAC1B,gCAAgC;AAEhC,SAAS,kBAAkB,WAAmB;IAC5C,IAAI,WAAW,SAAS,QAAQ;IAEhC,IAAI;QACF,uBAAuB;QACvB,WAAW,IAAI,IAAI,aAAa,QAAQ;IAC1C,EAAE,OAAO,GAAG,CAAC;IAEb,OAAO,aAAa,UAAU,OAAO;AACvC;AAWO,SAAS,mBAAmB,EAAmC;IACpE,eAAe,IAAI,CAAC;AACtB;AAEO,SAAS,YAAY,IAAS;IACnC,IAAI,CAAC,UAAU,OAAO,UAAU,KAAK,OAAO,IAAI,EAAE;IAClD,OAAO,OAAO,IAAI,CAAC;AACrB;AASO,SAAS,WAAW,OAAmB;IAC5C,MAAM,EAAE,UAAU,IAAI,IAAI,EAAE,GAAG;IAE/B,SAAS;QACP,IAAI,QAAQ,OAAO,KAAK;QAExB,QAAQ,GAAG,CAAC;QAEZ,SAAS;YACP,MAAM,YAAY;gBAAE,MAAM;YAA+B;YACzD,eAAe,OAAO,CAAC,CAAC;gBACtB,GAAG;YACL;YAEA,IAAI,QAAQ,GAAG,EAAE,QAAQ,GAAG,CAAC;QAC7B,4BAA4B;QAC9B;QAEA,SAAS,cAAc,KAAmB;YACxC,4BAA4B;YAE5B,MAAM,UAAU;gBACd,MAAM;gBACN,MAAM,KAAK,KAAK,CAAC,MAAM,IAAI;YAC7B;YACA,eAAe,OAAO,CAAC,CAAC;gBACtB,GAAG;YACL;QACF;QAEA,4BAA4B;QAE5B,SAAS;YACP,OAAO,KAAK;YACZ,WAAW,MAAM;QACnB;QAEA,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG;QAC3B,MAAM,WAAW,kBAAkB,QAAQ,WAAW,IAAI;QAC1D,MAAM,cAAc,QAAQ,WAAW,CAAC,OAAO,CAAC,QAAQ;QAExD,IAAI,MAAM,CAAC,EAAE,SAAS,GAAG,EAAE,SAAS,CAAC,EAAE,KAAK,EAC1C,cAAc,CAAC,CAAC,EAAE,YAAY,CAAC,GAAG,GACnC,CAAC;QAEF,IAAI,YAAY,UAAU,CAAC,SAAS;YAClC,MAAM,CAAC,EAAE,SAAS,GAAG,EAAE,YAAY,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QACtD;QAEA,SAAS,IAAI,OAAO,SAAS,CAAC,CAAC,EAAE,IAAI,EAAE,QAAQ,IAAI,CAAC,CAAC;QACrD,OAAO,MAAM,GAAG;QAChB,OAAO,OAAO,GAAG;QACjB,OAAO,SAAS,GAAG;IACrB;IAEA;AACF"}},
    {"offset": {"line": 2005, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2010, "column": 0}, "map": {"version":3,"sources":["/turbopack/[turbopack]/dev/client/hmr-client.ts"],"sourcesContent":["/// <reference path=\"../../shared/runtime-types.d.ts\" />\n/// <reference path=\"../runtime/base/globals.d.ts\" />\n/// <reference path=\"../runtime/base/protocol.d.ts\" />\n/// <reference path=\"../runtime/base/extensions.d.ts\" />\n\nimport {\n  addMessageListener as turboSocketAddMessageListener,\n  sendMessage as turboSocketSendMessage,\n} from \"./websocket\";\ntype SendMessage = typeof import(\"./websocket\").sendMessage;\n\nexport type ClientOptions = {\n  addMessageListener: typeof import(\"./websocket\").addMessageListener;\n  sendMessage: SendMessage;\n};\n\nexport function connect({\n  // TODO(WEB-1465) Remove this backwards compat fallback once\n  // vercel/next.js#54586 is merged.\n  addMessageListener = turboSocketAddMessageListener,\n  // TODO(WEB-1465) Remove this backwards compat fallback once\n  // vercel/next.js#54586 is merged.\n  sendMessage = turboSocketSendMessage,\n}: ClientOptions) {\n  addMessageListener((msg) => {\n    switch (msg.type) {\n      case \"turbopack-connected\":\n        handleSocketConnected(sendMessage);\n        break;\n      default:\n        if (Array.isArray(msg.data)) {\n          for (let i = 0; i < msg.data.length; i++) {\n            handleSocketMessage(msg.data[i] as ServerMessage);\n          }\n        } else {\n          handleSocketMessage(msg.data as ServerMessage);\n        }\n        applyAggregatedUpdates();\n        break;\n    }\n  });\n\n  const queued = globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS;\n  if (queued != null && !Array.isArray(queued)) {\n    throw new Error(\"A separate HMR handler was already registered\");\n  }\n  globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS = {\n    push: ([chunkPath, callback]: [ChunkPath, UpdateCallback]) => {\n      subscribeToChunkUpdate(chunkPath, sendMessage, callback);\n    },\n  };\n\n  if (Array.isArray(queued)) {\n    for (const [chunkPath, callback] of queued) {\n      subscribeToChunkUpdate(chunkPath, sendMessage, callback);\n    }\n  }\n}\n\ntype UpdateCallbackSet = {\n  callbacks: Set<UpdateCallback>;\n  unsubscribe: () => void;\n};\n\nconst updateCallbackSets: Map<ResourceKey, UpdateCallbackSet> = new Map();\n\nfunction sendJSON(sendMessage: SendMessage, message: ClientMessage) {\n  sendMessage(JSON.stringify(message));\n}\n\ntype ResourceKey = string;\n\nfunction resourceKey(resource: ResourceIdentifier): ResourceKey {\n  return JSON.stringify({\n    path: resource.path,\n    headers: resource.headers || null,\n  });\n}\n\nfunction subscribeToUpdates(\n  sendMessage: SendMessage,\n  resource: ResourceIdentifier\n): () => void {\n  sendJSON(sendMessage, {\n    type: \"turbopack-subscribe\",\n    ...resource,\n  });\n\n  return () => {\n    sendJSON(sendMessage, {\n      type: \"turbopack-unsubscribe\",\n      ...resource,\n    });\n  };\n}\n\nfunction handleSocketConnected(sendMessage: SendMessage) {\n  for (const key of updateCallbackSets.keys()) {\n    subscribeToUpdates(sendMessage, JSON.parse(key));\n  }\n}\n\n// we aggregate all pending updates until the issues are resolved\nconst chunkListsWithPendingUpdates: Map<ResourceKey, PartialServerMessage> =\n  new Map();\n\nfunction aggregateUpdates(msg: PartialServerMessage) {\n  const key = resourceKey(msg.resource);\n  let aggregated = chunkListsWithPendingUpdates.get(key);\n\n  if (aggregated) {\n    aggregated.instruction = mergeChunkListUpdates(\n      aggregated.instruction,\n      msg.instruction\n    );\n  } else {\n    chunkListsWithPendingUpdates.set(key, msg);\n  }\n}\n\nfunction applyAggregatedUpdates() {\n  if (chunkListsWithPendingUpdates.size === 0) return;\n  hooks.beforeRefresh();\n  for (const msg of chunkListsWithPendingUpdates.values()) {\n    triggerUpdate(msg);\n  }\n  chunkListsWithPendingUpdates.clear();\n  finalizeUpdate();\n}\n\nfunction mergeChunkListUpdates(\n  updateA: ChunkListUpdate,\n  updateB: ChunkListUpdate\n): ChunkListUpdate {\n  let chunks;\n  if (updateA.chunks != null) {\n    if (updateB.chunks == null) {\n      chunks = updateA.chunks;\n    } else {\n      chunks = mergeChunkListChunks(updateA.chunks, updateB.chunks);\n    }\n  } else if (updateB.chunks != null) {\n    chunks = updateB.chunks;\n  }\n\n  let merged;\n  if (updateA.merged != null) {\n    if (updateB.merged == null) {\n      merged = updateA.merged;\n    } else {\n      // Since `merged` is an array of updates, we need to merge them all into\n      // one, consistent update.\n      // Since there can only be `EcmascriptMergeUpdates` in the array, there is\n      // no need to key on the `type` field.\n      let update = updateA.merged[0];\n      for (let i = 1; i < updateA.merged.length; i++) {\n        update = mergeChunkListEcmascriptMergedUpdates(\n          update,\n          updateA.merged[i]\n        );\n      }\n\n      for (let i = 0; i < updateB.merged.length; i++) {\n        update = mergeChunkListEcmascriptMergedUpdates(\n          update,\n          updateB.merged[i]\n        );\n      }\n\n      merged = [update];\n    }\n  } else if (updateB.merged != null) {\n    merged = updateB.merged;\n  }\n\n  return {\n    type: \"ChunkListUpdate\",\n    chunks,\n    merged,\n  };\n}\n\nfunction mergeChunkListChunks(\n  chunksA: Record<ChunkPath, ChunkUpdate>,\n  chunksB: Record<ChunkPath, ChunkUpdate>\n): Record<ChunkPath, ChunkUpdate> {\n  const chunks: Record<ChunkPath, ChunkUpdate> = {};\n\n  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA)) {\n    const chunkUpdateB = chunksB[chunkPath];\n    if (chunkUpdateB != null) {\n      const mergedUpdate = mergeChunkUpdates(chunkUpdateA, chunkUpdateB);\n      if (mergedUpdate != null) {\n        chunks[chunkPath] = mergedUpdate;\n      }\n    } else {\n      chunks[chunkPath] = chunkUpdateA;\n    }\n  }\n\n  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB)) {\n    if (chunks[chunkPath] == null) {\n      chunks[chunkPath] = chunkUpdateB;\n    }\n  }\n\n  return chunks;\n}\n\nfunction mergeChunkUpdates(\n  updateA: ChunkUpdate,\n  updateB: ChunkUpdate\n): ChunkUpdate | undefined {\n  if (\n    (updateA.type === \"added\" && updateB.type === \"deleted\") ||\n    (updateA.type === \"deleted\" && updateB.type === \"added\")\n  ) {\n    return undefined;\n  }\n\n  if (updateA.type === \"partial\") {\n    invariant(updateA.instruction, \"Partial updates are unsupported\");\n  }\n\n  if (updateB.type === \"partial\") {\n    invariant(updateB.instruction, \"Partial updates are unsupported\");\n  }\n\n  return undefined;\n}\n\nfunction mergeChunkListEcmascriptMergedUpdates(\n  mergedA: EcmascriptMergedUpdate,\n  mergedB: EcmascriptMergedUpdate\n): EcmascriptMergedUpdate {\n  const entries = mergeEcmascriptChunkEntries(mergedA.entries, mergedB.entries);\n  const chunks = mergeEcmascriptChunksUpdates(mergedA.chunks, mergedB.chunks);\n\n  return {\n    type: \"EcmascriptMergedUpdate\",\n    entries,\n    chunks,\n  };\n}\n\nfunction mergeEcmascriptChunkEntries(\n  entriesA: Record<ModuleId, EcmascriptModuleEntry> | undefined,\n  entriesB: Record<ModuleId, EcmascriptModuleEntry> | undefined\n): Record<ModuleId, EcmascriptModuleEntry> {\n  return { ...entriesA, ...entriesB };\n}\n\nfunction mergeEcmascriptChunksUpdates(\n  chunksA: Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined,\n  chunksB: Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined\n): Record<ChunkPath, EcmascriptMergedChunkUpdate> | undefined {\n  if (chunksA == null) {\n    return chunksB;\n  }\n\n  if (chunksB == null) {\n    return chunksA;\n  }\n\n  const chunks: Record<ChunkPath, EcmascriptMergedChunkUpdate> = {};\n\n  for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA)) {\n    const chunkUpdateB = chunksB[chunkPath];\n    if (chunkUpdateB != null) {\n      const mergedUpdate = mergeEcmascriptChunkUpdates(\n        chunkUpdateA,\n        chunkUpdateB\n      );\n      if (mergedUpdate != null) {\n        chunks[chunkPath] = mergedUpdate;\n      }\n    } else {\n      chunks[chunkPath] = chunkUpdateA;\n    }\n  }\n\n  for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB)) {\n    if (chunks[chunkPath] == null) {\n      chunks[chunkPath] = chunkUpdateB;\n    }\n  }\n\n  if (Object.keys(chunks).length === 0) {\n    return undefined;\n  }\n\n  return chunks;\n}\n\nfunction mergeEcmascriptChunkUpdates(\n  updateA: EcmascriptMergedChunkUpdate,\n  updateB: EcmascriptMergedChunkUpdate\n): EcmascriptMergedChunkUpdate | undefined {\n  if (updateA.type === \"added\" && updateB.type === \"deleted\") {\n    // These two completely cancel each other out.\n    return undefined;\n  }\n\n  if (updateA.type === \"deleted\" && updateB.type === \"added\") {\n    const added = [];\n    const deleted = [];\n    const deletedModules = new Set(updateA.modules ?? []);\n    const addedModules = new Set(updateB.modules ?? []);\n\n    for (const moduleId of addedModules) {\n      if (!deletedModules.has(moduleId)) {\n        added.push(moduleId);\n      }\n    }\n\n    for (const moduleId of deletedModules) {\n      if (!addedModules.has(moduleId)) {\n        deleted.push(moduleId);\n      }\n    }\n\n    if (added.length === 0 && deleted.length === 0) {\n      return undefined;\n    }\n\n    return {\n      type: \"partial\",\n      added,\n      deleted,\n    };\n  }\n\n  if (updateA.type === \"partial\" && updateB.type === \"partial\") {\n    const added = new Set([...(updateA.added ?? []), ...(updateB.added ?? [])]);\n    const deleted = new Set([\n      ...(updateA.deleted ?? []),\n      ...(updateB.deleted ?? []),\n    ]);\n\n    if (updateB.added != null) {\n      for (const moduleId of updateB.added) {\n        deleted.delete(moduleId);\n      }\n    }\n\n    if (updateB.deleted != null) {\n      for (const moduleId of updateB.deleted) {\n        added.delete(moduleId);\n      }\n    }\n\n    return {\n      type: \"partial\",\n      added: [...added],\n      deleted: [...deleted],\n    };\n  }\n\n  if (updateA.type === \"added\" && updateB.type === \"partial\") {\n    const modules = new Set([\n      ...(updateA.modules ?? []),\n      ...(updateB.added ?? []),\n    ]);\n\n    for (const moduleId of updateB.deleted ?? []) {\n      modules.delete(moduleId);\n    }\n\n    return {\n      type: \"added\",\n      modules: [...modules],\n    };\n  }\n\n  if (updateA.type === \"partial\" && updateB.type === \"deleted\") {\n    // We could eagerly return `updateB` here, but this would potentially be\n    // incorrect if `updateA` has added modules.\n\n    const modules = new Set(updateB.modules ?? []);\n\n    if (updateA.added != null) {\n      for (const moduleId of updateA.added) {\n        modules.delete(moduleId);\n      }\n    }\n\n    return {\n      type: \"deleted\",\n      modules: [...modules],\n    };\n  }\n\n  // Any other update combination is invalid.\n\n  return undefined;\n}\n\nfunction invariant(never: never, message: string): never {\n  throw new Error(`Invariant: ${message}`);\n}\n\nconst CRITICAL = [\"bug\", \"error\", \"fatal\"];\n\nfunction compareByList(list: any[], a: any, b: any) {\n  const aI = list.indexOf(a) + 1 || list.length;\n  const bI = list.indexOf(b) + 1 || list.length;\n  return aI - bI;\n}\n\nconst chunksWithIssues: Map<ResourceKey, Issue[]> = new Map();\n\nfunction emitIssues() {\n  const issues = [];\n  const deduplicationSet = new Set();\n\n  for (const [_, chunkIssues] of chunksWithIssues) {\n    for (const chunkIssue of chunkIssues) {\n      if (deduplicationSet.has(chunkIssue.formatted)) continue;\n\n      issues.push(chunkIssue);\n      deduplicationSet.add(chunkIssue.formatted);\n    }\n  }\n\n  sortIssues(issues);\n\n  hooks.issues(issues);\n}\n\nfunction handleIssues(msg: ServerMessage): boolean {\n  const key = resourceKey(msg.resource);\n  let hasCriticalIssues = false;\n\n  for (const issue of msg.issues) {\n    if (CRITICAL.includes(issue.severity)) {\n      hasCriticalIssues = true;\n    }\n  }\n\n  if (msg.issues.length > 0) {\n    chunksWithIssues.set(key, msg.issues);\n  } else if (chunksWithIssues.has(key)) {\n    chunksWithIssues.delete(key);\n  }\n\n  emitIssues();\n\n  return hasCriticalIssues;\n}\n\nconst SEVERITY_ORDER = [\"bug\", \"fatal\", \"error\", \"warning\", \"info\", \"log\"];\nconst CATEGORY_ORDER = [\n  \"parse\",\n  \"resolve\",\n  \"code generation\",\n  \"rendering\",\n  \"typescript\",\n  \"other\",\n];\n\nfunction sortIssues(issues: Issue[]) {\n  issues.sort((a, b) => {\n    const first = compareByList(SEVERITY_ORDER, a.severity, b.severity);\n    if (first !== 0) return first;\n    return compareByList(CATEGORY_ORDER, a.category, b.category);\n  });\n}\n\nconst hooks = {\n  beforeRefresh: () => {},\n  refresh: () => {},\n  buildOk: () => {},\n  issues: (issues: Issue[]) => {},\n};\n\nexport function setHooks(newHooks: typeof hooks) {\n  Object.assign(hooks, newHooks);\n}\n\nfunction handleSocketMessage(msg: ServerMessage) {\n  sortIssues(msg.issues);\n\n  handleIssues(msg);\n\n  switch (msg.type) {\n    case \"issues\":\n      // issues are already handled\n      break;\n    case \"partial\":\n      // aggregate updates\n      aggregateUpdates(msg);\n      break;\n    default:\n      // run single update\n      const runHooks = chunkListsWithPendingUpdates.size === 0;\n      if (runHooks) hooks.beforeRefresh();\n      triggerUpdate(msg);\n      if (runHooks) finalizeUpdate();\n      break;\n  }\n}\n\nfunction finalizeUpdate() {\n  hooks.refresh();\n  hooks.buildOk();\n\n  // This is used by the Next.js integration test suite to notify it when HMR\n  // updates have been completed.\n  // TODO: Only run this in test environments (gate by `process.env.__NEXT_TEST_MODE`)\n  if (globalThis.__NEXT_HMR_CB) {\n    globalThis.__NEXT_HMR_CB();\n    globalThis.__NEXT_HMR_CB = null;\n  }\n}\n\nfunction subscribeToChunkUpdate(\n  chunkPath: ChunkPath,\n  sendMessage: SendMessage,\n  callback: UpdateCallback\n): () => void {\n  return subscribeToUpdate(\n    {\n      path: chunkPath,\n    },\n    sendMessage,\n    callback\n  );\n}\n\nexport function subscribeToUpdate(\n  resource: ResourceIdentifier,\n  sendMessage: SendMessage,\n  callback: UpdateCallback\n) {\n  // TODO(WEB-1465) Remove this backwards compat fallback once\n  // vercel/next.js#54586 is merged.\n  if (callback === undefined) {\n    callback = sendMessage;\n    sendMessage = turboSocketSendMessage;\n  }\n\n  const key = resourceKey(resource);\n  let callbackSet: UpdateCallbackSet;\n  const existingCallbackSet = updateCallbackSets.get(key);\n  if (!existingCallbackSet) {\n    callbackSet = {\n      callbacks: new Set([callback]),\n      unsubscribe: subscribeToUpdates(sendMessage, resource),\n    };\n    updateCallbackSets.set(key, callbackSet);\n  } else {\n    existingCallbackSet.callbacks.add(callback);\n    callbackSet = existingCallbackSet;\n  }\n\n  return () => {\n    callbackSet.callbacks.delete(callback);\n\n    if (callbackSet.callbacks.size === 0) {\n      callbackSet.unsubscribe();\n      updateCallbackSets.delete(key);\n    }\n  };\n}\n\nfunction triggerUpdate(msg: ServerMessage) {\n  const key = resourceKey(msg.resource);\n  const callbackSet = updateCallbackSets.get(key);\n  if (!callbackSet) {\n    return;\n  }\n\n  try {\n    for (const callback of callbackSet.callbacks) {\n      callback(msg);\n    }\n\n    if (msg.type === \"notFound\") {\n      // This indicates that the resource which we subscribed to either does not exist or\n      // has been deleted. In either case, we should clear all update callbacks, so if a\n      // new subscription is created for the same resource, it will send a new \"subscribe\"\n      // message to the server.\n      // No need to send an \"unsubscribe\" message to the server, it will have already\n      // dropped the update stream before sending the \"notFound\" message.\n      updateCallbackSets.delete(key);\n    }\n  } catch (err) {\n    console.error(\n      `An error occurred during the update of resource \\`${msg.resource.path}\\``,\n      err\n    );\n    location.reload();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2478, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}