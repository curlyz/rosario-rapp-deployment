{"version":3,"file":"static/chunks/pages/_error-10f24c55ebcc462a.js","mappings":"sFACKA,OAAOC,SAAWD,OAAOC,UAAY,IAAIC,KAAK,CAC7C,UACA,WACE,OAAO,EAAQ,W,gICIvBC,eAAeC,EAAgCC,GAC7C,MAAM,IAAEC,EAAG,IAAEC,EAAG,IAAEC,GAAQH,EAGpBI,EAAa,GAAQF,EAAIE,YAAeJ,EAAeI,WAC7D,OAAIA,GAAcA,EAAa,IACtBC,QAAQC,UAUZN,EAAeO,WAIpBC,EAAAA,EAAAA,KAAUC,IACJR,GACFQ,EAAMC,yBAAyB,CAAEC,QAASV,KAK5CW,EAAAA,EAAAA,IAAiBT,GAAO,sCAA0C,OAAJA,EAAI,KAAI,CACpEU,UAAW,CACTC,KAAM,aACNC,SAAS,EACTC,KAAM,CACJC,SAAU,2CCKpBnB,iBACE,IACEoB,EAAAA,GAAeC,EAAAA,GAAOC,IAAI,4BACpBC,EAAAA,EAAAA,IAAM,KACZH,EAAAA,GAAeC,EAAAA,GAAOC,IAAI,wBAC1B,MAAOE,GACPJ,EAAAA,GAAeC,EAAAA,GAAOC,IAAI,iCAAkCE,IDHxDC,KAvBGlB,QAAQC,U,wBEtBnB,MAAMkB,EAAwBC,IACrB,SAACC,IAAKA,CAACtB,WAAYqB,EAAMrB,aAGlCoB,EAAqBG,gBAAkB7B,MAAO8B,UAGtCC,EAAuCD,GAGtCF,IAAAA,gBAAsBE,IAG/B,S,sBChBAE,EAAOC,QAAU,EAAjB,S","sources":["webpack://_N_E/?fa0a","webpack://_N_E/./node_modules/@sentry/nextjs/esm/common/_error.js","webpack://_N_E/./node_modules/@sentry/nextjs/esm/common/utils/responseEnd.js","webpack://_N_E/./src/pages/_error.jsx","webpack://_N_E/./node_modules/next/error.js"],"sourcesContent":["\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_error\",\n      function () {\n        return require(\"private-next-pages/_error.jsx\");\n      }\n    ]);\n    if(module.hot) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_error\"])\n      });\n    }\n  ","import { withScope, captureException } from '@sentry/core';\nimport { flushQueue } from './utils/responseEnd.js';\n\n/**\n * Capture the exception passed by nextjs to the `_error` page, adding context data as appropriate.\n *\n * @param contextOrProps The data passed to either `getInitialProps` or `render` by nextjs\n */\nasync function captureUnderscoreErrorException(contextOrProps) {\n  const { req, res, err } = contextOrProps;\n\n  // 404s (and other 400-y friends) can trigger `_error`, but we don't want to send them to Sentry\n  const statusCode = (res && res.statusCode) || contextOrProps.statusCode;\n  if (statusCode && statusCode < 500) {\n    return Promise.resolve();\n  }\n\n  // In previous versions of the suggested `_error.js` page in which this function is meant to be used, there was a\n  // workaround for https://github.com/vercel/next.js/issues/8592 which involved an extra call to this function, in the\n  // custom error component's `render` method, just in case it hadn't been called by `getInitialProps`. Now that that\n  // issue has been fixed, the second call is unnecessary, but since it lives in user code rather than our code, users\n  // have to be the ones to get rid of it, and guaraneteedly, not all of them will. So, rather than capture the error\n  // twice, we just bail if we sense we're in that now-extraneous second call. (We can tell which function we're in\n  // because Nextjs passes `pathname` to `getInitialProps` but not to `render`.)\n  if (!contextOrProps.pathname) {\n    return Promise.resolve();\n  }\n\n  withScope(scope => {\n    if (req) {\n      scope.setSDKProcessingMetadata({ request: req });\n    }\n\n    // If third-party libraries (or users themselves) throw something falsy, we want to capture it as a message (which\n    // is what passing a string to `captureException` will wind up doing)\n    captureException(err || `_error.js called with falsy error (${err})`, {\n      mechanism: {\n        type: 'instrument',\n        handled: false,\n        data: {\n          function: '_error.getInitialProps',\n        },\n      },\n    });\n  });\n\n  // In case this is being run as part of a serverless function (as is the case with the server half of nextjs apps\n  // deployed to vercel), make sure the error gets sent to Sentry before the lambda exits.\n  await flushQueue();\n}\n\nexport { captureUnderscoreErrorException };\n//# sourceMappingURL=_error.js.map\n","import { flush, setHttpStatus } from '@sentry/core';\nimport { logger, fill } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\n\n/**\n * Wrap `res.end()` so that it ends the span and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe, because the native `.end()` actually *is* (effectively) async, and\n * its run actually *is* (literally) awaited, just manually so (which reflects the fact that the core of the\n * request/response code in Node by far predates the introduction of `async`/`await`). When `.end()` is done, it emits\n * the `prefinish` event, and only once that fires does request processing continue. See\n * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.\n *\n * Also note: `res.end()` isn't called until *after* all response data and headers have been sent, so blocking inside of\n * `end` doesn't delay data getting to the end user. See\n * https://nodejs.org/api/http.html#responseenddata-encoding-callback.\n *\n * @param span The span tracking the request\n * @param res: The request's corresponding response\n */\nfunction autoEndSpanOnResponseEnd(span, res) {\n  const wrapEndMethod = (origEnd) => {\n    return function sentryWrappedEnd( ...args) {\n      finishSpan(span, this);\n      return origEnd.call(this, ...args);\n    };\n  };\n\n  // Prevent double-wrapping\n  // res.end may be undefined during build when using `next export` to statically export a Next.js app\n  if (res.end && !(res.end ).__sentry_original__) {\n    fill(res, 'end', wrapEndMethod);\n  }\n}\n\n/** Finish the given response's span and set HTTP status data */\nfunction finishSpan(span, res) {\n  if (span) {\n    setHttpStatus(span, res.statusCode);\n    span.end();\n  }\n}\n\n/** Flush the event queue to ensure that events get sent to Sentry before the response is finished and the lambda ends */\nasync function flushQueue() {\n  try {\n    DEBUG_BUILD && logger.log('Flushing events...');\n    await flush(2000);\n    DEBUG_BUILD && logger.log('Done flushing events');\n  } catch (e) {\n    DEBUG_BUILD && logger.log('Error while flushing events:\\n', e);\n  }\n}\n\nexport { autoEndSpanOnResponseEnd, finishSpan, flushQueue };\n//# sourceMappingURL=responseEnd.js.map\n","import * as Sentry from \"@sentry/nextjs\";\nimport Error from \"next/error\";\n\nconst CustomErrorComponent = (props) => {\n  return <Error statusCode={props.statusCode} />;\n};\n\nCustomErrorComponent.getInitialProps = async (contextData) => {\n  // In case this is running in a serverless function, await this in order to give Sentry\n  // time to send the error before the lambda exits\n  await Sentry.captureUnderscoreErrorException(contextData);\n\n  // This will contain the status code of the response\n  return Error.getInitialProps(contextData);\n};\n\nexport default CustomErrorComponent;\n","module.exports = require('./dist/pages/_error')\n"],"names":["window","__NEXT_P","push","async","captureUnderscoreErrorException","contextOrProps","req","res","err","statusCode","Promise","resolve","pathname","withScope","scope","setSDKProcessingMetadata","request","captureException","mechanism","type","handled","data","function","DEBUG_BUILD","logger","log","flush","e","flushQueue","CustomErrorComponent","props","Error","getInitialProps","contextData","Sentry","module","exports"],"sourceRoot":""}